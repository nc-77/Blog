[{"categories":["CSAPPLab"],"content":"实验说明 在这个实验中，我们将实现一个多线程带缓存的代理服务器，听起来是不是很cool，而且这个实验最终可以不只是以一个打分结束，这个完全手写的代理服务器还可以真正用在浏览器上。\n先来一波实验效果图。推荐使用firefox进行测试，设置如下：\n如果是在远程服务器上开启的服务，填服务器的公网ip+对应端口\n本地就是loaclhost或者127.0.0.1+对应端口了\n测试网站：http://home.baidu.com/home/index/contact_us\n代理服务未启动前：\n代理服务启动后：\n注：本实验所有代码均已上传至github上，需要自取\n前置知识 客户端—服务器编程模型 需要注意的是，客户端和服务器是进程，而不是主机。一台主机上可以同时运行许多不同的客户端和服务器。\n因特网连接 因特网客户端和服务器通过在连接上发送和接收字节流来通信，并且这种连接是点对点的，具体来说，是通过socket来实现的。\nsocket地址是由一个因特网地址和一个16位的整数端口组成的，形如”地址：端口“，一个socket就是连接的一个端点。\n所以一个连接是由它两端的socket地址唯一确定的。形如（clientaddr：cliport，servaddr：servport）,如下图。\n具体连接过程 先上书上的一张向导图。\n从客户端开始说起\n  将服务器的ip+端口通过getaddrinfo转换成socket地址结构\n  利用socket函数来创建一个socket descriptor——clientfd，客户端将通过读写clientfd来与服务器进行通信，当然，此时的clientfd仅仅是打开的，还不能用于读写。\n  客户端通过connet函数与目标服务器建立一个因特网连接，connet会阻塞，一直到连接成功建立或是发生错误，如果成功，就可以通过读写clientfd来与服务器进行通信了。\n  再来说服务器这边\n 将服务器的端口通过getaddrinfo转换成socket地址结构 同客户端一样创建一个socket descriptor——listenfd，但这个listenfd并不直接与客户端进行实质内容上的通信，listenfd仅作为客户端连接请求的一个端点，并存在与服务器的整个周期。 bind将刚刚生成的listenfd与客户端地址绑定起来。 listen告诉内核将listenfd从一个主动套接字转化为一个监听套接字，该套接字可以接受来自客户端的请求。 至此，服务器的准备工作都做完了，接下来就是accept客户端的connect了，服务器会等待来自客户端的连接请求到达listenfd并生成一个已连接描述符（connected descriptor),服务器通过读写connfd来与客户端进行通信。  这里有一个问题，服务器的listenfd与connfd有什么区别，为什么需要两个，这是因为它使得我们可以实现并发服务器，每次一个连接请求到listenfd，我们可以fork一个新的进程，通过新的connfd与客户端进行通信，从而能够同时处理许多客户端的连接。\n值得一提的是，从linux的角度来看，socket就是一个有相应描述符的打开文件。\nPART1 前面说了这么多，让我们直接进入实战吧。\n当然，在做这个lab之前，推荐先去把书上实现的一个tiny server复现一下。\npart1部分其实要做的工作很少，我们只需要在书上实现的tiny server框架下改写实现一个proxy能转发客户端的请求到服务器，同时服务器的回复也通过proxy转发到客户端。\n我的思路是这样的，proxy相对于客户端而言是作为服务器的，相对于服务器而言又作为客户端，相当于proxy充当了客户端和服务器的双重身份。\n因此proxy总体的框架如下所示（是相当于客户端的服务器）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  #include \"csapp.h\"#include \"doit.h\" int main(int argc,char **argv) { int listenfd,connfd; socklen_t clientlen; char *port; char hostname[MAXLINE]; struct sockaddr_storage clientaddr; if (argc != 2) { fprintf(stderr, \"usage: %s \u003cport\u003e\\n\", argv[0]); exit(1); } port=argv[1]; listenfd=Open_listenfd(port); while (1) { clientlen = sizeof(clientaddr); connfd = Accept(listenfd, (SA *)\u0026clientaddr, \u0026clientlen); Getnameinfo((SA *) \u0026clientaddr, clientlen, hostname, MAXLINE, port, MAXLINE, 0); printf(\"Accepted connection from (%s, %s)\\n\", hostname, port); doit(connfd); Close(connfd); } return 0; }   其中doit部分要处理的就是接受客户端Req并发送至服务器，最后再向客户端发送服务器的response。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  void doit(int listenfd) { /* 通过读写listenfd 与客户端通信 通过读写clientfd 与服务端通信 */ rio_t rio_listen,rio_client; int n; char buf[MAXLINE],method[MAXLINE],uri[MAXLINE],version[MAXLINE]; char newreq[MAXLINE+20]; Request req; int clientfd; /* proxy 接收客户端 Req */ Rio_readinitb(\u0026rio_listen,listenfd); Rio_readlineb(\u0026rio_listen,buf,MAXLINE); printf(\"Request line:\\n\"); printf(\"%s\\n\",buf); sscanf(buf,\"%s %s %s\",method,uri,version); if(strcasecmp(method,\"GET\")){ /* 忽略除get外所有请求 */ clienterror(listenfd,method,\"501\",\"Not implemented\",\"Tiny does not implement this method\"); return; } /* 忽略所有请求报头 */ read_requestHeaders(\u0026rio_listen); /* 解析uri */ parse_uri(\u0026req,uri); /* 浏览器使用 */ sprintf(newreq, \"GET http://%s:%s%s HTTP/1.0\\r\\n\\r\\n\", req.host,req.port,req.path); /* drive.sh 测试用 */ //sprintf(newreq, \"GET %s HTTP/1.0\\r\\n\\r\\n\", req.path);  /* proxy 向服务端发送 request */ clientfd=Open_clientfd(req.host,req.port); Rio_writen(clientfd,newreq,MAXLINE); printf(\"proxy send request successfully\\n\"); /* proxy 向客户端发送 response */ Rio_readinitb(\u0026rio_client,clientfd); while ((n = Rio_readlineb(\u0026rio_client, buf, MAXLINE))) {//real server response to buf  printf(\"proxy received %d bytes,then send\\n\",n); Rio_writen(listenfd, buf, n); //real server response to real client  } Close(clientfd); }   辅助函数 read_requesetHeaders 读取所有请求头并忽略\n1 2 3 4 5 6 7 8 9  void read_requestHeaders(rio_t *rp){ char buf[MAXLINE]; memset(buf,0,sizeof(buf)); printf(\"request headers:\\n\"); while(strcmp(buf,\"\\r\\n\")){ Rio_readlineb(rp,buf,MAXLINE); printf(\"%s\",buf); } }   parse_uri 分割Req中的host，port，path，没有指明的端口默认80\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  void parse_uri(Request *req,char *uri){ //printf(\"parse_uri begin\\n\");  if (strstr(uri, \"http://\") != uri) { fprintf(stderr, \"Error: invalid uri!\\n\"); exit(0); } uri += strlen(\"http://\"); char *c = strstr(uri, \":\"); if(!c){ /* 无显示端口默认80 */ strcpy(req-\u003eport,\"80\"); c = strstr(uri, \"/\"); *c = '\\0'; strcpy(req-\u003ehost, uri); *c = '/'; strcpy(req-\u003epath, c); } else{ *c = '\\0'; strcpy(req-\u003ehost, uri); uri = c + 1; c = strstr(uri, \"/\"); *c = '\\0'; strcpy(req-\u003eport, uri); *c = '/'; strcpy(req-\u003epath, c); } //printf(\"parse_uri end\\n\");  //printf(\"host=%s,port=%s,path=%s\\n\",req-\u003ehost,req-\u003eport,req-\u003epath); }   用提供的./drive.sh 测试一下\n基础的部分都拿到了，代表我们已经实现了一个单线程无缓存的超级简陋的proxy。当然，即使这个只有最基本的功能，你也可以像文章开头一样在浏览器中使用这个proxy。\nPART2 实现多线程\n咕~\nPART3 实现缓存\n一意咕行~\n总结 这是csapp中的最后一个lab了，写完就相当于结束了csapp系列。写下csapp的阅读感受吧。\n从这学期初开始阅读csapp，花了差不多半个学期多的时间，跟着b站上的视频囫囵吞枣过了一遍，毕竟还没正式接触过计网，计组和操作系统。虽然感觉老师上课一些的概念已经讲的简单化了，但是很是有许多一知半解的东西。其间还跳过了一些偏硬件的章节。\n当然，给我帮助最大的还是csapp配套的lab，代码注入攻击，实现内存管理器，实现一个shell，实现一个proxy......这些在以前看来是想都不敢想的事情，但是跟着这些lab，我也都自己做出来了（虽然不是很完善，而且借鉴了网上其他人的做法）。\n总而言之，阅读完csapp给我最大的感受是开阔了眼界吧，估计以后系统学完计算机知识后应该会再来重温一遍这本经典吧，毕竟还留了几个坑在这儿。\n临近考试周，这应该是本学期最后一篇博客了吧，下次应该是2020年总结（先立个flag,逃）\n","description":"","tags":["csapp","计算机网络"],"title":"ProxyLab","uri":"/posts/proxylab/"},{"categories":["数据结构与算法"],"content":"写在前面 本篇文章旨在提供解题思路以及代码参考，切勿直接抄袭（PTA有代码查重系统）\n欢迎大家在评论区提出疑惑和代码的缺陷，有更好的想好也欢迎交流。\n约瑟夫环 题目详情 N个人围成一圈顺序编号，从1号开始按1、2、3......顺序报数，报p者退出圈外，其余的人再从1、2、3开始报数，报p的人再退出圈外，以此类推。 请按退出顺序输出每个退出人的原序号。\n解题思路 模拟题意即可。刚开始有n个人在圈内，我们使用$index=(i+n-1)%n+1$保证编号在始终在[1，n]内，使用a数组记录每个人是在圈内还是圈外，每次开始报数从上一次中止的下一位开始，检查每个人的状态，不在圈内就跳过，报到P时，标记$a[index]=0$，同时alive--,直到alive==0为止\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  #include\u003cstdio.h\u003eint a[3010]; int main() { int n,p; scanf(\"%d%d\",\u0026n,\u0026p); int alive=n;// 刚开始有n个人在圈内  int now=1; for(int i=1;i\u003c=n;i++) a[i]=1; int first=1; while(alive\u003e0){ int cnt=0; for(int i=now;;i++){ /* 保证每次序号都在[1,n]内 */ int index=(i+n-1)%n+1; /* 如果已经不在圈内,跳过 */ if(!a[index]) continue; cnt++; if(cnt==p){ a[index]=0; /* 处理行尾空格问题 */ if(first){ printf(\"%d\",index); first=0; } else printf(\" %d\",index); alive--; /* 从下一位开始 */ now=i+1; break; } } } return 0; }   哈夫曼编码 题目详情 给定一段文字，如果我们统计出字母出现的频率，是可以根据哈夫曼算法给出一套编码，使得用此编码压缩原文可以得到最短的编码总长。然而哈夫曼编码并不是唯一的。例如对字符串\"aaaxuaxz\"，容易得到字母 'a'、'x'、'u'、'z' 的出现频率对应为 4、2、1、1。我们可以设计编码 {'a'=0, 'x'=10, 'u'=110, 'z'=111}，也可以用另一套 {'a'=1, 'x'=01, 'u'=001, 'z'=000}，还可以用 {'a'=0, 'x'=11, 'u'=100, 'z'=101}，三套编码都可以把原文压缩到 14 个字节。但是 {'a'=0, 'x'=01, 'u'=011, 'z'=001} 就不是哈夫曼编码，因为用这套编码压缩得到 00001011001001 后，解码的结果不唯一，\"aaaxuaxz\" 和 \"aazuaxax\" 都可以对应解码的结果。本题就请你判断任一套编码是否哈夫曼编码。\n解题思路 我们可以先根据原字符串构建哈夫曼树求出最少所需的字节数量。\n利用哈夫曼树求解具体流程如下（通过维护一个优先队列实现）：\n 将所有字符的出现次数push到队列中 优先队列pop出两个最小值x,y 最终答案加上x+y，并将x+y push到队列 重复2，3操作直到队列为空  当然，C中并没有优先队列（连队列都没有怎么可能有优先队列），因此，我将优先队列pop操作改成了成普通队列中遍历寻找两个最小值。当然，有能力和时间的小伙伴可以手写一个最小堆来实现优先队列。\n算出最优解以后，我们需要将每个方案的总字节数与最优解做个比对，不一样肯定就\"No\"了，但是一样的话还需要判断方案中是否满足前缀码的需求，即方案中任意一个字符的编码都不能成为其他字符编码的前缀。\n这个前缀码我选择了建树来判断，对于每个方案建一棵01树，判断一下插入的路径上是否有节点对应其他字符，如果有的话就代表该字符不满足前缀码的要求。具体看下图（以输入样例中最后一个方案作为例子）。\n红色的三个点就发生了前缀冲突。\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141  #include\u003cstdio.h\u003e#include\u003cmalloc.h\u003e#include\u003cstring.h\u003e#define inf 0x3f3f3f3f int ch[1010]; int que[1010]; int n,m; int tail,head,size; int vis[1010];// 标记队列中已经被去除的元素 typedef struct solution { char sol_ch[1010][1010]; //记录每个方案中每个字符的编码 }solution; typedef struct node { int flag;// 代表该节点为一个字符的编码  struct node *left,*right; }node; void read() { /* 读入原字符 */ scanf(\"%d\",\u0026n); for(int i=0;i\u003cn;i++){ char one_ch; int one_cnt; getchar();// 去上一行的回车  scanf(\"%c %d\",\u0026one_ch,\u0026one_cnt); ch[one_ch-'0']=one_cnt; que[tail++]=one_cnt; size++; } } /* 计算采取哈夫曼编码的情况下的最优解 */ int cul_ans(){ int ans=0; while(size\u003e0){ if(size\u003e=2){ /* 找队列中最小的两个值xy */ int x=inf,y=inf; int x_index,y_index; for(int i=head;i\u003ctail;i++){ if(vis[i]) continue; if(que[i]\u003cx){ x=que[i]; x_index=i; } } vis[x_index]=1; for(int i=head;i\u003ctail;i++){ if(vis[i]) continue; if(que[i]\u003cy){ y=que[i]; y_index=i; } } vis[y_index]=1; ans+=(x+y); size-=2; /* 让(x+y) 入队 */ que[tail++]=(x+y); size+=1; } else if(size==1){ int index=que[head]; ans+=ch[index]; size--; } } return ans; } /* 检查是否符合前缀编码 */ int check(char * s,node *T) { int size=strlen(s); for(int i=0;i\u003csize;i++) { if(s[i]=='0'){ if(!T-\u003eleft){ node *tmp=(node *)malloc(sizeof(node)); tmp-\u003eleft=tmp-\u003eright=NULL; tmp-\u003eflag=0; T-\u003eleft=tmp; } else{ if(T-\u003eleft-\u003eflag) {return 0;} } T=T-\u003eleft; } else{ if(!T-\u003eright){ node *tmp=(node *)malloc(sizeof(node)); tmp-\u003eleft=tmp-\u003eright=NULL; tmp-\u003eflag=0; T-\u003eright=tmp; } else{ if(T-\u003eright-\u003eflag) {return 0;} } T=T-\u003eright; } } if(T-\u003eright||T-\u003eleft) return 0; T-\u003eflag=1; return 1; } int main() { read(); int ans=cul_ans(); scanf(\"%d\",\u0026m); for(int i=0;i\u003cm;i++){ /* 读入并检查每个方案 */ int res=0; int flag=1; solution Solution; /* 初始化01树 */ node* root=(node *)malloc(sizeof(node)); root-\u003eleft=root-\u003eright=NULL; for(int j=0;j\u003cn;j++){ getchar(); //去上一行的回车  char one_ch; scanf(\"%c\",\u0026one_ch); getchar(); scanf(\"%s\",Solution.sol_ch[one_ch-'0']); /* res统计总字节数 */ res+=ch[one_ch-'0']*strlen(Solution.sol_ch[one_ch-'0']); if(flag) flag=check(Solution.sol_ch[one_ch-'0'],root); } if(res==ans\u0026\u0026flag) puts(\"Yes\"); else puts(\"No\"); } return 0; }   集合的“交”与“并” 题目详情 给出两个由数字组成的集合，请求这两个集合的“交”和“并”。\n解题思路 考虑最朴素的思想，要求交集，可以将a数列每个元素都在b数列里扫一遍，存在的话就加入到交集里。\n这种方法的时间复杂度是$o(nm)$\n但是看下数据范围，每个数列至多会有2e5个元素。$2e5*2e5=4e10$,显然是会超时的（一般能过的代码时间复杂度要求在1e6-1e7之间，1e8就挺玄学了），因此我们需要对这个算法进行优化。\n很容易想到，除了顺序查找方式，我们还可以用二分查找，二分查找的时间复杂度是$o(logm)$，这样就不会超时了，当然二分查找的前提是数组要有序，因此我们先排个序，排序的时候也要注意不能使用冒泡，选择等$o(n^2)$的排序算法，可以使用c库中提供的qsort快排。\n交集解决了，考虑并集。并集简单多了，直接将a数列和b数列合并后排个序，当然输出的时候要注意去重，其实也很简单，输出的时候看一下前面的那个元素和当前这个元素是不是一样的，如果相同就跳过（伪去重，有点钻空子）。\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#define maxn 400010 int a[maxn],b[maxn],c[maxn],d[maxn]; int n,m; int comp(const void*a,const void*b) { return *(int*)a-*(int*)b; } /* 二分查找 b数组中是否有x */ int find(int x) { int l=0,r=m; int mid; while(l\u003cr){ mid = l + r \u003e\u003e 1; if (x\u003cb[mid]) r = mid; else if(x==b[mid]) return 1; else l = mid + 1; } return 0; } int main() { scanf(\"%d %d\",\u0026n,\u0026m); for(int i=0;i\u003cn;i++) { scanf(\"%d\",\u0026a[i]); c[i]=a[i]; } for(int i=0;i\u003cm;i++) { scanf(\"%d\",\u0026b[i]); c[n+i]=b[i]; } /* 将a,b,c三个数组升序排序 */ qsort(a,n,sizeof(int),comp); qsort(b,m,sizeof(int),comp); qsort(c,m+n,sizeof(int),comp); /* 求交集 */ int same=0; for(int i=0;i\u003cn;i++){ if(find(a[i])){ d[same++]=a[i]; } } printf(\"%d\",same); for(int i=0;i\u003csame;i++){ printf(\" %d\",d[i]); } printf(\"\\n\"); printf(\"%d\",m+n-same); for(int i=0;i\u003cm+n;i++){ /* 去重 */ if(i\u0026\u0026c[i]==c[i-1]) continue; printf(\" %d\",c[i]); } return 0; }   停车场管理 题目详情 设有一个可以停放n辆汽车的狭长停车场，它只有一个大门可以供车辆进出。车辆按到达停车场时间的先后次序依次从停车场最里面向大门口处停放 (即最先到达的第一辆车停放在停车场的最里面) 。如果停车场已放满n辆车，则以后到达的车辆只能在停车场大门外的便道上等待，一旦停车场内有车开走，则排在便道上的第一辆车可以进入停车场。停车场内如有某辆车要开走，则在它之后进入停车场的车都必须先退出停车场为它让路，待其开出停车场后，这些车辆再依原来的次序进场。每辆车在离开停车场时，都应根据它在停车场内停留的时间长短交费，停留在便道上的车不收停车费。编写程序对该停车场进行管理。\n解题思路 模拟题意就好了。特别需要注意的点是需要标记一下目前哪些车在停车场内，当一辆车驶离停车场的时候要先判断该车是否在停车场内，不在则输出“the car not in park”，不然会卡测试点2。\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103  #include\u003cstdio.h\u003e#include\u003cstring.h\u003e#include\u003ctime.h\u003eint pos[1500]; // 停车位 int n; int vis[10500]; //来过车的信息 typedef struct car { int A_Time; int D_Time; int stat; //停在哪个车位 }Car; typedef struct Que { int q[10500]; int head,tail,size; }Que; Que que; Car car[10500]; int check_empty() { for(int i=1;i\u003c=n;i++){ if(pos[i]==0) return i; } return 0; } int main() { int first=1; scanf(\"%d\",\u0026n); getchar(); char op; int car_id,Time; while(1){ scanf(\"%c %d %d\",\u0026op,\u0026car_id,\u0026Time); if(op=='E') break; if(op=='D'){ /* 车驶离的时候先判断原来是否在停车场 */ if(!vis[car_id]){ printf(\"the car not in park\\n\"); continue; } /* 驶离操作 */ int pos_id=car[car_id].stat; car[car_id].D_Time=Time; pos[pos_id]=0; vis[car_id]=0; printf(\"car#%d out,parking time %d\\n\",car_id,Time-car[car_id].A_Time); /* 调整停车场次序,将后面的车全部往前移一位*/ for(int i=pos_id;i\u003c=n;i++){ if(pos[i+1]) { car[pos[i+1]].stat=i; pos[i]=pos[i+1]; } else{ pos[i]=0; break; } } /* 有新空位让队列首停车 */ if(que.size\u003e0){ que.size--; /* top取出队列首 */ int top=que.q[que.head++]; int new_pos_id=check_empty(); vis[top]=1; pos[new_pos_id]=top; car[top].A_Time=Time; car[top].stat=new_pos_id; printf(\"car#%d in parking space #%d\\n\",top,new_pos_id); } } else if(op=='A'){ int pos_id=check_empty(); if(pos_id){ /* 有空位 */ pos[pos_id]=car_id; car[car_id].A_Time=Time; car[car_id].stat=pos_id; vis[car_id]=1; printf(\"car#%d in parking space #%d\\n\",car_id,pos_id); } else{ /* 需等待 */ que.q[que.tail++]=car_id; que.size++; printf(\"car#%d waiting\\n\",car_id); } } } return 0; }   魔王语言解释 1 2  #include\u003cstdio.h\u003eint main(){puts(\"tsaedsaeezegexeneietsaedsae\");}   逃）\n最短路径 题目详情 给定一个有N个顶点和E条边的无向图，顶点从0到N−1编号。请判断给定的两个顶点之间是否有路径存在。如果存在，给出最短路径长度。 这里定义顶点到自身的最短路径长度为0。 进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。\n解题思路 考察最短路。求解最短路常用的有三个算法，Bellman-Ford,\tDijkstra 以及Floyd（提供了之前自己写的解析）\n看下数据，N只有10，因此我选择了写起来最方便的floyd算法。\n但是本题的测试点2我用floyd算法一直过不去，询问老师后得知测试点2是no path的情况。\n所以又写了个dfs来判断能否到达，能到达的情况下再输出通过最短路算法得到的最短路径。\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  #include\u003cstdio.h\u003e#define inf 0x3f3f3f3f #define min(a,b) (a)\u003c(b)?(a):(b) /* d[i][j]存储i到j的距离 */ int d[15][15]; int n,m; /* floyd算法求解最短路 */ void floyd() { for(int k=0;k\u003cn;k++) for(int i=0;i\u003cn;i++) for(int j=0;j\u003cn;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]); } int vis[15]; int flag; int start,end; /* dfs判断能否从start到达end */ void dfs(int now) { /* 标记过已到达的点 */ vis[now]=1; /* 能到达标记 flag为1 */ if(now==end) flag=1; /* flag为1后直接return */ if(flag) return; for(int i=0;i\u003cn;i++) { if(d[now][i]==1\u0026\u0026!vis[i]){ dfs(i); } } } int main() { scanf(\"%d%d\",\u0026n,\u0026m); for(int i=0;i\u003cm;i++) { int x,y; scanf(\"%d%d\",\u0026x,\u0026y); d[x][y]=d[y][x]=1; } scanf(\"%d%d\",\u0026start,\u0026end); /* 初始化距离 */ for(int i=0;i\u003cn;i++) for(int j=0;j\u003cn;j++) { if(d[i][j]) continue; if(i==j) d[i][j]=0; else d[i][j]=inf; } floyd(); vis[start]=1; /* 判断能否从start到达end */ dfs(start); if(!flag){ printf(\"There is no path between %d and %d.\",start,end); } else{ printf(\"The length of the shortest path between %d and %d is %d.\",start,end,d[start][end]); } return 0; }   周游世界 题目详情 周游世界是件浪漫事，但规划旅行路线就不一定了…… 全世界有成千上万条航线、铁路线、大巴线，令人眼花缭乱。所以旅行社会选择部分运输公司组成联盟，每家公司提供一条线路，然后帮助客户规划由联盟内企业支持的旅行路线。本题就要求你帮旅行社实现一个自动规划路线的程序，使得对任何给定的起点和终点，可以找出最顺畅的路线。所谓“最顺畅”，首先是指中途经停站最少；如果经停站一样多，则取需要换乘线路次数最少的路线。\n解题思路 个人感觉这应该是期末验收里最难做的一道了。\n由于笔者使用的是Bellman_ford求解最短路，不懂的可以先戳这 -\u003eBellman_Ford\n由于最后输出的路径首要前提是最短路径，然后在最短路径的基础上保证换乘最少，因此我们可以考虑使用Bellman_ford求解最短路的过程中增添一些东西，不仅需要pre记录路径前驱（pre[i]表示i的前驱），还需要一个company数组来记录到达该站点最后所走的路线，一个transfer数组来记录到达该站点所需要的换乘次数，最后在最短路更新的过程中维护这几个数组就好了。\n输出的时候还原路径也比较麻烦，可以先根据pre前驱得到路径上所有的站点，然后再根据company所记录的路线选取需要换乘的那些站点。\n总而言之，这道题写起来是挺麻烦的，需要你对最短路算法的更新过程有本质的理解，但相信我，独立写出这道题会让你对最短路算法有更深刻的理解。\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125  #include\u003cstdio.h\u003e#include\u003cstring.h\u003e#define maxn 100000 #define inf 0x3f3f3f3f int V,E;// 顶点数,边数 int d[maxn],vis[maxn]; int transfer[maxn];// 每个站点换乘次数 int pre[maxn],path[maxn]; // 记录前驱 int pos[maxn]; // 存储最终路径 int company[maxn]; // 每个站点由哪条路线过来 typedef struct edge { int from,to,cost; int company; }edge; edge es[maxn]; void add_edge(int from,int to,int line){ es[E].from=from; es[E].to=to; es[E].cost=1; es[E].company=line; E++; } void bellman_ford(int start){ /* pre记录路径 */ memset(pre,-1,sizeof(pre)); memset(d,0x3f,sizeof(d)); d[start]=0; for(int i=0;i\u003cV;i++){ /* flag标记本次是否更新,不加会超时*/ int flag=0; for(int j=0;j\u003cE;j++){ edge e=es[j]; if(d[e.to]\u003ed[e.from]+e.cost){ d[e.to]=d[e.from]+e.cost; pre[e.to]=e.from; company[e.to]=e.company; transfer[e.to]=transfer[e.from]; /* 需要换乘 */ if(e.company!=company[e.from]){ transfer[e.to]++; } flag=1; } else if(d[e.to]==d[e.from]+e.cost){ /* 距离相同的情况下换乘次数更少则更新 */ if(transfer[e.to]\u003etransfer[e.from]+(e.company!=company[e.from])){ company[e.to]=e.company; pre[e.to]=e.from; transfer[e.to]=transfer[e.from]+(e.company!=company[e.from]); flag=1; } } } /* 如果此次没更新代表之后也不会更新,直接return */ if(!flag) return; } } void get_path(int start,int end) //还原路径 { if(d[end]==inf){ printf(\"Sorry, no line is available.\\n\"); return; } /* path存储路径上的每个站点 pos存储需要换乘的站点 */ int path_cnt=0 ,pos_cnt=0,tmp=end; /* 根据pre前驱记录还原path */ while(1){ path[path_cnt++]=tmp; if(pre[tmp]==-1) break; tmp=pre[tmp]; } /* 根据path选取出需要换乘的站点 */ pos[pos_cnt++]=start; for(int i=path_cnt-2;i\u003e0;i--){ if(company[path[i]]!=company[path[i-1]]) pos[pos_cnt++]=path[i]; } pos[pos_cnt++]=end; printf(\"%d\\n\",path_cnt-1); for(int i=0;i\u003cpos_cnt-1;i++){ printf(\"Go by the line of company #%d from %04d to %04d.\\n\",company[pos[i+1]],pos[i],pos[i+1]); } } int main() { int n; scanf(\"%d\",\u0026n); for(int i=0;i\u003cn;i++){ int k; scanf(\"%d\",\u0026k); V+=k; int pre_station=-1; /* 建图 */ while(k--){ int this_station; scanf(\"%4d\",\u0026this_station); if(pre_station!=-1){ add_edge(pre_station,this_station,i+1); add_edge(this_station,pre_station,i+1); } pre_station=this_station; } } int Q; scanf(\"%d\",\u0026Q); while(Q--){ int start,end; scanf(\"%4d%4d\",\u0026start,\u0026end); bellman_ford(start); get_path(start,end); } return 0; }   任务调度的合理性 题目详情 假定一个工程项目由一组子任务构成，子任务之间有的可以并行执行，有的必须在完成了其它一些子任务后才能执行。“任务调度”包括一组子任务、以及每个子任务可以执行所依赖的子任务集。\n比如完成一个专业的所有课程学习和毕业设计可以看成一个本科生要完成的一项工程，各门课程可以看成是子任务。有些课程可以同时开设，比如英语和C程序设计，它们没有必须先修哪门的约束；有些课程则不可以同时开设，因为它们有先后的依赖关系，比如C程序设计和数据结构两门课，必须先学习前者。\n但是需要注意的是，对一组子任务，并不是任意的任务调度都是一个可行的方案。比如方案中存在“子任务A依赖于子任务B，子任务B依赖于子任务C，子任务C又依赖于子任务A”，那么这三个任务哪个都不能先执行，这就是一个不可行的方案。你现在的工作是写程序判定任何一个给定的任务调度是否可行。\n解题思路 经典拓扑排序题。\n先说下拓扑排序的流程，维护一个队列。\n  找到入度为0的点，将这些点加入到队列中\n  从队列中取出一个点top，删除top连出去的所有边（将g[top] [i]置为0)\n  每删除一条边判断删除后该点入度是否为0，为0且不在队列中就入队\n  重复1，2，3直到队列为空或找不到入度为0的点\n  走完流程后判断一下是否所有点入度均为0，是的话代表该图存在拓扑序，否则不存在。\n有个麻烦的地方在于C中没有队列，因此需要用数组模拟一下队列。\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  #include\u003cstdio.h\u003eint g[105][105];/* 记录边 */ int in[105];/* 记录每个点的入度 */ int vis[105];/* 记录是否访问过 */ int que[105];/* 模拟队列 */ int n; void bfs(){ int tail=0,head=0,size=0; /* 将入度为0的点加入队列 */ for(int i=1;i\u003c=n;i++){ if(!in[i]){ que[tail++]=i; vis[i]=1; size++; } } while(size\u003e0){ /* 取出队头元素 */ int top=que[head++]; size--; for(int i=1;i\u003c=n;i++){ /* 删边 */ if(g[top][i]){ g[top][i]=0; in[i]--; /* 入度为0且没访问过就入队 */ if(in[i]==0){ if(!vis[i]) { que[tail++]=i; vis[i]=1; size++; } } } } } return; } int main() { scanf(\"%d\",\u0026n); for(int i=1;i\u003c=n;i++){ int k; scanf(\"%d\",\u0026k); in[i]=k; while(k--){ int x; scanf(\"%d\",\u0026x); g[x][i]=1; } } bfs(); /* sum表示所有点入度和 */ int sum=0; for(int i=1;i\u003c=n;i++){ sum+=in[i]; } if(sum) printf(\"0\"); else printf(\"1\"); return 0; }   ","description":"","tags":["PTA","模拟","图","树"],"title":"HDU数据结构期末验收","uri":"/posts/pta/"},{"categories":["CSAPPLab"],"content":"实验说明 在这个实验中，我们将实现C中的malloc，free和remalloc函数。\nCSAPP的mallocLab提供了一个基本的框架和10个测试文件。\n我们只需完成mm.c文件。\n因为在实验过程中，我们可能需要编写几个不同版本的mm.c文件，因此为了保存不同的版本，可能需要重新组织一下文件结构。\n下面安利一下我本人采取的文件结构并放上测试流程。（从github上clone下来可直接食用）\ncd my_malloc /* 完成mm.c文件 */ make clean make ./mdriver 好了，在确保阅读了CSAPP中的第9章以及实验的Writeup,就开始我们的malloc之旅吧。\n注：本文章三个版本malloc代码已上传至github（有详细的注释）。\n隐式链表+First_fit 衡量一个内存分配器的好坏的两个指标是内存利用率和吞吐率。这两者往往是矛盾的，因此我们要寻找一个平衡点（当然其实内存利用率更重要一点，毕竟内存=money）\n让我们考虑如何组织一个动态内存分配器，内存分配器本质是在一大块字节数组（称之为堆）中分配一些字节数组（称之为块）提供给用户。因此我们整个设计都是围绕如何组织空闲块和遍历空闲块。\n对应的，书上介绍了三种组织空闲块的方式和三种寻找空闲块的方式。\n隐式空闲链表、显示空闲链表、分离的空闲链表和首次适配，下次适配，最佳适配。\n笔者尝试了三种组合：\n  隐式空闲链表+First_fit\n  隐式空闲链表+Next_fit\n  分离空闲链表+First_fit\n  强烈建议先从第一种开始熟悉下整个框架，而且书本基本给出了第一种的完整代码。\n堆块的结构和堆整体结构如下图。\n我们可以将堆组织为一个连续的已分配块和空闲块的序列（隐式空闲链表）。这样当我们寻找空闲块的时候，只需按照头部和尾部的块大小信息来遍历整个堆。\n这种组织方式的优点是简单。但缺点就是malloc操作的时间开销太大，因为我们每次搜索时间的大小都与整个堆大小呈线性关系。\n书中采取的是First_fit匹配方式，即找到第一个满足条件的空闲块就停止。\n由于书上已经把完整代码给出来了，这里就不放了，然后测试一下书上的代码。\n好吧，看来书上的代码成绩并不是很理想，我们发现thru的分数过低，所以接下来让我们换Next_fit试一下。\n隐式链表+Next_fit 将First_fit改成Next_fit，即每次搜索空闲块的时候从上一次搜索到空闲块的地方开始，它源于这样一个思想：如果我们上次在某个空闲块里已经发现了一个匹配，那么很可能下一次我们也能在这个剩余块中发现匹配。显然，这样的思想能使我们的搜索效率提升，但代价就是内存利用率会低得多。\n1 2 3 4 5 6 7 8 9 10  static void *next_fit(size_t size){ for (char* bp = pre_listp; GET_SIZE(HEAD(bp)) \u003e 0; bp = NEXT_BLKP(bp)) { if (!GET_ALLOC(HEAD(bp)) \u0026\u0026 GET_SIZE(HEAD(bp)) \u003e= size) { return bp; } } return NULL; }   提一下用这个方法的时候踩的坑吧，记录上一次结果的pre_listp除了要在mm_init和place中更新外，在coalesce中也要记得更新pre_listp（这个bug调了一年），因为合并块的时候会更改bp的位置，如果之前pre_listp恰好在合并前的bp位置，不更新就会导致之后非空闲块被覆盖。\n改完后测试一下。\n嗯。时间效率一下提升了不少，而且内存利用率也没有降低的很多，这种方案已经到达及格线了。最后再让我们尝试一下分离空闲链表。\n分离空闲链表+First_fit 我们考虑将空闲链表采用显式链表的方式组合，这样能将时间复杂度从搜索整个堆降低为搜索堆中的空闲块。\n更进一步，我们将这个显式链表分成若干个链表，分类的依据是链表中每个空闲块的大小。\n例如，我们可以根据2的幂来划分：\n{1}，{2}，{3，4}，{5~8}，...，{1025 ~2048 }，{2049~4096}，{4097 ~ $\\infty$}\n这样，分配器维护一个空闲链表数组，当分配器需要一个大小为$n$的块时，它就搜索相应大小的空闲链表。如果不能找到合适的块与之分配，它就搜索下一个空闲链表。\n画个图直观的感受一下。\nC中真正的malloc实现也是采用了分离空闲链表的思想。\n在脑中有了这个组织架构后，我们就开始实现我们的想法吧。\n完整代码在此处，因为有详细的注释，就不再讲解了。直接放下最后跑分结果吧。（终于上90了，完结撒花）\n总结 这次Lab断断续续做了一周左右（其实主要时间花在debug上了），而且还参考了大量前人的博客，可以说是所有Lab中最难且花费时间最多的一个了。之前从来没有尝试过全是指针的编程，但是在做个实验的过程中，不得不感叹，指针真是个有魅力的家伙，用的好挥斥方遒，用不好就各种segfalut了。\n本来这个实验看起来这么硬核，当我完成Nextfit取得80分的时候就想放弃了，但是看到书上的最后一种方法以及体验了指针的魅力之后，还是坚持了下去（调指针bug太痛苦了）。相应地，完完整整做完这个实验带给你的感悟绝对不是书上的理论能比拟的，对内存中的每个字节操作，一招不慎，满盘皆输，但不得不说太cool了。\n只剩最后一个Lab了，可惜期中检查周来了，要还债了，还有新苗项目的报备，可能最后的一个Lab要咕好久了吧。（逃\n","description":"","tags":["内存分配","csapp"],"title":"MallocLab","uri":"/posts/malloclab/"},{"categories":["CSAPPLab"],"content":"前置知识 这篇文章主要围绕CMU的CSAPP中的ShellLab来讲（ShellLab实现一个简易的unix下的shell，光听就感觉很激动吧）\n讲什么\n 完成ShellLab所需知识（对应CSAPP第八章，仅作复习使用，如果从未接触过请去看原书）  进程 信号   ShellLab实验文件 ShellLab中的注意点和坑点  注：本篇文章所有代码已上传至github，lab须在Linux环境下运行\n进程 进程可以说是计算机科学中最深刻，最成功的概念之一。打开你的任务管理器，是不是有一堆进程正在运行中，想象一下，如果没有进程，你的计算机每时每刻只能运行一个程序，是不是很崩溃的画面。\n但是在现代操作系统中，我们正在使用的程序往往给我们这是系统中当前运行唯一的程序一样，处理器似乎就在单独执行我们这个程序一样。然而，这些都是通过进程模拟出来的假象。\n进程提供给程序的关键抽象：\n 一个独立的逻辑控制流。它提供一个假象，好像我们的程序独占地使用处理器。 一个私有的地址空间。它提供一个假象，好像我们的程序独占地使用内存系统。  逻辑控制流 首先，我们要有一个概念。进程是轮流使用CPU的。\n如图，这三个进程的逻辑流是交错运行的。进程A运行了一会儿，接着轮到进程B，然后是进程B开始运行到结束。然后，进程C运行了一会儿，进程A紧接着运行到完成，最后，进程C可以运行到结束。\n一个逻辑流的执行在时间上与另一个流重叠，称为并发流，比如上图中的A与B，A与C，但是B与C并不是并发，因为在C开始运行前B已经结束运行。\n私有地址空间 进程为每个程序提供它的私有地址空间。一般而言，该地址空间中的内存是不能被其他进程读写的。\n尽管每个私有地址空间存储内容不同，但是他们有相同的通用结构，如下图是x86-64 Linux进程的地址空间的组织结构。\n创建和终止进程 进程总是处于以下三种状态：\n 运行 停止（被挂起，但是依然存在） 终止（永远地停止了，不再存在于内存中）  我们可以通过在父进程中调用fork函数来创建一个子进程。子进程将得到与父进程虚拟地址空间相同但是独立的副本，两者最大的区别在于他们拥有不同的PID。\nfork函数调用一次，但是却返回两次——在父进程中，fork返回子进程的PID；在子进程中，fork返回0\n正如上文中所说，进程之间是并发执行的。因此对于父进程和子进程，我们绝不能对不同进程中指令的交替执行做任何假设。（这点很重要!!!）\n当一个进程终止时，它会一直保持在一种已终止的状态中，直到被它的父进程回收。我们将一个终止了但还未被回收的进程称为僵死进程。\n一个进程可以通过调用wait或waitpid函数来等待它的子进程终止或者停止（具体函数可在man中查看），然后父进程会回收这个子进程，内核将抹去被回收进程的所有痕迹。\n信号 信号是不同进程中相互通信的方式，它允许进程和内核中断其他进程。\n一般而言，每种信号类型都对应于某种系统事件。例如，平时使用shell的时候，当进程在前台运行时，键入Ctrl+c内核将会发送一个SIGINT信号给这个前台进程组的每个进程。（SIGINT默认行为为终止）当一个子进程终止或者停止时，内核也发送一个SIGCHLD信号给父进程。\n接收与阻塞信号 当进程收到内核发来的信号时，进程可以忽略，终止或者通过一个信号处理程序的用户层函数来捕获这个信号。\n一个发出而没有被接收的信号叫做待处理信号。在任何时刻，一种类型至多只会有一个待处理信号。\n也就是说，如果进程中有一个待处理信号，那么同类型的信号将不再被接受，也不会排队等待，而是直接被丢弃。但是，一个进程可以阻塞某种信号，当某种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接受，直到进程取消对这种信号的阻塞。\n下图为阻塞SIGINT信号的例子。（具体相关sigprocmask等信号函数请查看man文档）\n编写信号处理程序 编写一个安全的信号处理程序很麻烦，因为主程序和这些信号处理程序是并发运行的。如果这些程序都需要访问同样的全局变量，但是由于我们无法预测这些程序指令的先后顺序，那么结果往往是不可预知的。因此在编写信号处理程序时往往有以下规则。\n  处理程序尽可能简单。\n  在处理程序中只调用异步信号安全（可重入，不能被信号处理程序打断）的函数（printf，malloc和exit都不在此列）\n  保存和恢复error。\n  阻塞所有信号，保护对共享全局数据结构的访问。\n  用volatile声明全局变量。\n  用sig_atmoic_t 声明标志。（原子操作，不可被打断）\n  由于同一类型信号不会排队。因此如果存在一个未处理的信号就表明至少有一个信号到达了\n  当有父子进程中某部分有明确的执行顺序时，注意阻塞信号来避免父子进程之间的竞争。\n  ShellLab 实验文件 实验文件下载\n在开始做这个lab之前请认真阅读writeup和对应的csapp第8章。\n实验要求完成tsh.c这个文件实现一个shell，大致框架已经搭好，我们只需完成其中的空白函数。\ntshref是一个成品，我们需要让我们的tsh和tshref的输出完全一致（除PID外）。\ntracexx.txt是测试文件，推荐trace一个一个测试过来逐步完善我们的tsh。\n常用命令如下：\n1 2 3 4 5 6 7 8 9 10  /* 编译生成tsh */ make clean make /* *测试trace01 *test为tsh输出 *rtest为rtsh输出 */ make test01 make rtest01   eval 书本p525已经为我们展示了一个大致框架。但是还存在几个问题需要改进\n  后台子进程运行完没回收，会成为僵尸进程\n  需要维护一个jobs（表示正在运行的进程）\n  Hints:\n 维护jobs通过已给出的addjob和deletjob实现，但我们需要防止父子进程之间的竞争，防止子进程在父进程addjob前结束，触发SIGICHLD信号导致先执行了deletjob。因此需要在父进程fork前阻塞SIGCHLD信号 父进程fork每个子进程后需每个子进程设立一个新的进程组，避免之后的SIGINT信号终止所有子进程  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  void eval(char *cmdline) { char buf[MAXLINE]; strcpy(buf,cmdline); char *argv[MAXARGS]; pid_t pid; int bg=parseline(buf,argv); /* run bg or fg */ sigset_t mask_one; sigemptyset(\u0026mask_one); sigaddset(\u0026mask_one,SIGCHLD); if(argv[0]==NULL) return; if(!builtin_cmd(argv)){ /*if builtin_cmd execute immediately,if not fork and execute*/ sigprocmask(SIG_BLOCK,\u0026mask_one,NULL); /* 阻塞SIGCHLD防止竞争,确保正确addjob */ if((pid=Fork())==0){ /* child */ sigprocmask(SIG_UNBLOCK,\u0026mask_one,NULL); /* 子进程继承父进程BOLCK,需要取消子进程阻塞 */ setpgid(0,0); /* 为每个进程设立一个新的进程组 */ if(execve(argv[0],argv,environ)\u003c0){ printf(\"%s: Commond not found\\n\",argv[0]); exit(0); } } /* parent wait for fg job to terminate */ int state=(bg? BG:FG); addjob(jobs,pid,state,cmdline); /* 后台程序在printf后再解除CHLD阻塞防止在printf前被CHLD信号打断 */ //sigprocmask(SIG_UNBLOCK,\u0026mask_one,NULL);  if(!bg) { sigprocmask(SIG_UNBLOCK,\u0026mask_one,NULL); /* 解除父进程CHLD阻塞 */ waitfg(pid); } else{ printf(\"[%d] (%d) %s\",pid2jid(pid),pid,cmdline); sigprocmask(SIG_UNBLOCK,\u0026mask_one,NULL); /* 解除父进程CHLD阻塞 */ } } return; }   builtin_cmd 处理内置命令的函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  int builtin_cmd(char **argv) { if(!strcmp(argv[0],\"quit\")) exit(0); else if(!strcmp(argv[0],\"jobs\")){ listjobs(jobs); return 1; } else if(!strcmp(argv[0],\"bg\")||!strcmp(argv[0],\"fg\")){ do_bgfg(argv); return 1; } return 0; /* not a builtin command */ }   waitfg 等待前台进程结束\nHints:\n sigsuspend(\u0026mask)函数用mask临时代替当前进程的阻塞集合，挂起该进程等待一个信号 用sleep（） 间隔太小会浪费循环 间隔太大又会导致程序太慢 用pause（）存在竞争的风险，即CHLD信号在while和pause之间被接受会导致永久的pause  1 2 3 4 5 6 7 8 9  void waitfg(pid_t pid) { sigset_t mask_empty; sigemptyset(\u0026mask_empty); while(fgpid(jobs)==pid){ /* 等待fg结束向父进程发送SIGCHLD信号 */ sigsuspend(\u0026mask_empty); } return; }   sigchld_handler Hints：\n waitpid函数第三个参数需设置WNOHANG|WUNTRACED，表示即使子进程STOP也直接返回 利用返回的status判断子进程目前状态并作相应处理 访问全局变量记得阻塞信号 保存之前errno并在返回前恢复  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  void sigchld_handler(int sig) { int olderrno=errno; pid_t pid; sigset_t mask_all,prev; sigfillset(\u0026mask_all); int status; while((pid=waitpid(-1,\u0026status,WNOHANG|WUNTRACED))\u003e0){ /* WNOHANG 所有子进程终止后返回 | WUNTRACED 即使进程被ST也立即返回 */ if(WIFEXITED(status)){ /* 进程正常终止 */ sigprocmask(SIG_BLOCK,\u0026mask_all,\u0026prev); /* 访问全局变量jobs上阻塞 */ deletejob(jobs,pid); sigprocmask(SIG_SETMASK,\u0026prev,NULL); /* 解除阻塞 */ } else if(WIFSIGNALED(status)){ /* 进程由于SIGINT信号终止 */ sigprocmask(SIG_BLOCK,\u0026mask_all,\u0026prev); printf(\"Job [%d] (%d) terminated by signal %d\\n\",pid2jid(pid),pid,SIGINT); /* 这里printf非异步函数,其实不应该用在此处 */ deletejob(jobs,pid); sigprocmask(SIG_SETMASK,\u0026prev,NULL); } else if(WIFSTOPPED(status)){ /* 进程由于SIGTSTP信号挂起 */ struct job_t *job=getjobpid(jobs,pid); sigprocmask(SIG_BLOCK,\u0026mask_all,\u0026prev); printf(\"Job [%d] (%d) stoped by signal %d\\n\",pid2jid(pid),pid,SIGTSTP); /* 这里printf非异步函数,其实不应该用在此处 */ job-\u003estate=ST; sigprocmask(SIG_SETMASK,\u0026prev,NULL); } } errno=olderrno; return; }   sigint_handler 实现ctrl+c 向当前前台进程组发送SIGINT信号\nHints:\n kill（pid_t pid,int _sig）发送sig信号到pid，pid\u003c-1时表示发送到-pid的整个进程组  1 2 3 4 5 6 7 8 9 10 11  void sigint_handler(int sig) { int olderrno=errno; pid_t pid=fgpid(jobs); if(pid){ kill(-pid,SIGINT); } errno=olderrno; return; }   sigstp_handler 实现ctrl+z 向当前前台进程组发送SIGTSTP信号\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  void sigtstp_handler(int sig) { int olderrno=errno; pid_t pid=fgpid(jobs); if(pid){ struct job_t *job=getjobpid(jobs,pid); if(job-\u003estate==ST) /* 已经停止了 */ return; else kill(-pid,SIGTSTP); } errno=olderrno; return; }   do_bgfg Hints:\n 部分前后台程序可能被挂起，先发送SIGCONT信号 后台程序转到前台运行时需等待其运行完  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  void do_bgfg(char **argv) { if(argv[1]==NULL){ printf(\"%s command requires PID or %%jobid argument\\n\",argv[0]); return; } int id; struct job_t *job; /* 按\u0026%d格式读取jid */ if(sscanf(argv[1],\"%%%d\",\u0026id)\u003e0){ job=getjobjid(jobs,id); if(job==NULL){ printf(\"(%d): No such job\\n\",id); return; } } /* 按%d格式读取pid */ else if(sscanf(argv[1],\"%d\",\u0026id)\u003e0){ job=getjobpid(jobs,id); if(job==NULL){ printf(\"%s: No such process\\n\",argv[1]); return; } } /* 格式错误 */ else{ printf(\"%s: argument must be a PID or %%jobid\\n\",argv[0]); return; } kill(-(job-\u003epid),SIGCONT); if(!strcmp(\"bg\",argv[0])){ printf(\"[%d] (%d) %s\",job-\u003ejid,job-\u003epid,job-\u003ecmdline); job-\u003estate=BG; } else{ /*job转到前台运行并等待job运行完 */ job-\u003estate=FG; waitfg(job-\u003epid); } return; }   总结 目前做了4个lab中这个ShellLab给我的感触是最深的，算上这篇blog ，这部分内容断断续续做了一周左右的时间。当然，其中的有些内容还是有点迷迷糊糊，希望能在之后再能系统地学习一次。但是，不管怎么说，个人认为CSAPP给我带来的帮助是很大的，尤其是配套的lab实验认认真真的做，相信会让你对计算机的认识有翻天覆地的变化。\n最后，希望自己能一直保持初心，毕竟可能有只有这段大学时光能做到不那么功利，去读自己想读的书，做自己想做的事。\n共勉。\n","description":"","tags":["异常控制流","进程","信号","csapp"],"title":"ShellLab","uri":"/posts/shelllab/"},{"categories":["计算机基础"],"content":"编译 说来惭愧，大一写代码的时候以为代码必须要在ide才能运行。后来在使用VScode的过程中逐渐明白了代码从一段文本到一个可执行程序背后发生的事情。\n以c程序为例，最终成为可被机器执行的代码，包含以下步骤:\n  预处理：处理c程序中#define,#include部分，类似作文本替换\n  编译器: 将经过预处理的c代码转换成汇编代码（gcc -s）生成.s汇编文件\n  汇编器：将汇编代码转成可重定位目标文件（.o) 对应命令（gcc -c)\n  链接器： 将各个可重定位目标文件链接成为计算机可执行文件\n  让我们来看一个具体的例子，假设我们有两段代码main.c和sum.c,其中main调用了sum\n1 2 3 4 5 6 7 8 9  int sum(int *a, int n); int array[2] = {1, 2}; int main() { int val = sum(array, 2); return val; }   1 2 3 4 5 6 7 8  int sum(int *a, int n) { int i, s = 0; for (i = 0; i \u003c n; i++) s += a[i]; return s; }   gcc -c main.c sum.c -c参数 表示只编译不进行链接，因此我们会得到main.o 和sum.o两个目标文件（但是未经过链接还不能被机器直接运行）\ngcc -o prog main.o sum.o -o 表示为生成的文件命名，通过链接器我们会得到一个prog的可执行文件\n当然，在实际编译中，我们往往直接使用\ngcc -o prog main.c sum.c 会直接得到一个prog的可执行文件，编译器帮我们做了许多背后的工作。\n接下来本文重点介绍其中的链接部分。\n链接器 链接器在构造可执行文件中主要完成两个任务:\n  符号解析:\n为c语言中的每个函数、变量创建一个符号，方便在链接的过程中引用这些函数和变量\n  重定位：\n我们知道，.o文件实际上就是一些字节序列，链接器需要将各个经过符号解析的符号与真实的内存位置对应起来，进行重定位，从而组织成一个新的可执行文件。\n  链接器的目标对象就是我们上文中提到的.o文件（可重定位目标文件），除此之外还有.out(可执行目标文件)和.so(共享目标文件，下文动态链接中会提到)。\n在Linux中，这三种对象文件都有一种统一的格式——ELF。\n其中的细节部分读者若感兴趣可以翻阅CSAPP第7章相关内容。\n下面介绍链接的两种方式：静态链接和动态链接\n静态链接 在实际的使用当中，人们常常将一些常用的函数封装成库。实际上，所有的编译系统都提供一种机制，将所有相关的目标模块打包成一个单独的文件，称为静态库。当链接器构造一个可执行文件时，它只复制静态库里被应用程序引用的目标模块。\n在Linux中，静态库以存档(.a)文件的格式存储。我们可以使用AR工具来打包一个静态库。例如:\n我们有两个函数addvec和mulvec分别存储于addvec.c和mulvec.c\nint addcnt=0; void addvec(int *x,int *y,int *z){ z[0]=x[0]+y[0]; z[1]=x[1]+y[1]; addcnt++; } int addcnt=0; void addvec(int *x,int *y,int *z){ z[0]=x[0]+y[0]; z[1]=x[1]+y[1]; addcnt++; } gcc -c addvec.c mulvec.c ar rcs libvector.a addvec.o mulvec.o 我们会得到一个libvector.a文件，这就是我们打包完成的库了。\n接下来再与main.c进行链接生成prog的可执行文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13  #include\u003cstdio.h\u003eextern int addcnt; extern int mulcnt; void addvec(int *x,int *y,int * z); void mulvec(int *x,int *y,int * z); int x[2]={1,2}; int y[2]={3,4}; int z[2]; int main() { addvec(x,y,z); printf(\"z[0]=%d,z[1]=%d,addcnt=%d,mulcnt=%d\\n\",z[0],z[1],addcnt,mulcnt); }   gcc -static -o prog main.o libvector.a 另外值得一提的是,当我们将主程序文件与库进行链接时，需要将静态库放在最后，原因是当链接器使用静态库来解析引用时是从左到右按照它们在命令行出现的顺序来扫描可重定位文件和存档文件。\n例如，刚刚的例子中，我们如果将libvec.a放在main.o前面，就会出现这种情况（链接器根据顺序搜索找不到addvec函数）\n还有一种情况，假设foo.c调用libx.a的函数，而libx.a和liby.a又相互依赖，那么libx.a就需要重复出现\ngcc foo.c libx.a liby.a libx.a 动态链接共享库 之前提到的静态链接方式其实是一种古老的链接方式，现在的技术往往采用动态链接。主要原因是几乎每个c程序都会使用标准函数，例如printf和scanf，使用静态链接会将这些函数的代码重复复制到每个运行进程的文本段中。导致有限的内存中存在着大量的标准函数的副本，这是一种极大的内存浪费。\n共享库就是一种解决这个问题的创新产物。在Linux中为.so后缀文件，在windows被称作DLL(动态链接库)。\n首先还是以上面的例子创建一个动态库\ngcc -shared -fpic -o libvector.so addvec.c mulvec.c 然后将动态库与main.c进行链接\ngcc -o prog2 main.c ./libvector.so 乍一看是不是和静态库的操作没什么区别，但其实隐藏在命令背后的原理是完全不同的。\n动态链接的基本思路是当创建可执行文件时，静态执行一些链接，然后在程序加载时动态完成链接过程。此时，没有任何libvector.so的代码和数据真的被复制到prog2中，链接器只是复制了一些重定位和符号表信息。也就是说，prog运行的时候必须依靠本地的libvector.so，而静态链接完成后即使本地不存在libvecot.a，prog运行也能运行，这也是笔者认为两者链接方式的最大区别。\n我们可以看下两种链接方式产生的prog可执行文件大小。\n可以看到，动态链接的文件大小小得多。\n顺带一提，我们可以使用ldd filename来查看可执行文件的动态库依赖\ngcc目前默认采用动态链接，同时会默认添加libc.so标准c共享库\n","description":"","tags":["编译原理","链接"],"title":"Linking","uri":"/posts/%E9%93%BE%E6%8E%A5/"},{"categories":["机器学习"],"content":"问题引入 在2000年和2004年的美国总统大选中，候选人的得票数比较接近或者说非常接近。任一候选 人得到的普选票数的最大百分比为50.7%，而最小百分比为47.9%。如果1%的选民将手中的选票 投向另外的候选人，那么选举结果就会截然不同。实际上，如果妥善加以引导与吸引，少部分选 民就会转换立场。尽管这类选举者占的比例较低，但当候选人的选票接近时，这些人的立场无疑 会对选举结果产生非常大的影响。如何找出这类选民，以及如何在有限的预算下采取措施来吸 引他们？答案就是聚类。\n显然，在无监督学习中，由于训练样本的标记是未知的，但是我们可以通过训练样本的内在性质以及特征规律，将样本分成若干类来为数据分析提供基础，这种分类方法就称作聚类。\n如图，我们的目标就是将图中若干个二维数据点进行分类。下面介绍一种应用广泛的原型聚类算法：K—Means。\n注：本篇文章所有代码及数据集已上传至github\nK—Means K—Means的工作流程如下。\n  以上图为例，我们可以将所有样本大致分为k个簇。因此，我们在原来的样本域中随机选取k个点作为初始簇心。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  #数据预处理(准备工作): #loadDataSet: 读取样本集,转换成array #calDist: 求两个向量的欧氏距离 #randCent: 随机初始化簇心 import pandas as pd import numpy as np from math import * import random import matplotlib.pyplot as plt plt.style.use('ggplot') def loadDataSet(filename): df=pd.read_csv(filename,sep='\\t',header=None) return df.to_numpy() #cnt 存储每次训练结果png的编号 def plotDataSet(dataMat,cnt,centroids=None,clusterAssess=None): colors=['green','red','black','brown'] fig,ax=plt.subplots() if(centroids is None): ax.scatter(dataMat[:,0],dataMat[:,1]) else: colorsList=[colors[int(x)] for x in clusterAssess[:,0]] ax.scatter(dataMat[:,0],dataMat[:,1],color=colorsList) ax.scatter(centroids[:,0],centroids[:,1],color='blue',marker='x') ax.set_xlabel('X1') ax.set_ylabel('X2') plt.savefig(f\"kmeans{cnt}\") def calDist(vecA,vecB): return sqrt(sum(np.power(vecA-vecB,2))) def randCent(dataMat,k): m,n=dataMat.shape centroids=np.zeros((k,n)) for i in range(n): #print(min(dataMat[:,i]),max(dataMat[:,i])) dataMin=min(dataMat[:,i]) dataMax=max(dataMat[:,i]) # 为每个簇心随机生成[dataMin,dataMax]的坐标 for j in range(k): centroids[j,i]=random.uniform(dataMin,dataMax) return centroids     我们为所有样本找到距离最近的簇心，并将该样本分配到这个簇中。（X表示簇心，相同颜色的点表示分到同一个簇中）\n  取每个簇中所有样本特征的平均值，重新确定簇心的位置。\n  回到2，迭代更新\n  当所有样本的颜色不变时，退出更新，训练结束\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  from operator import itemgetter def KMeans(dataMat,k,calDis=calDist,creatCent=randCent): m,n=dataMat.shape # clusterAssess 一列记录簇索引，一列记录误差（距离簇心距离） clusterAssess=np.zeros((m,2)) centroids=creatCent(dataMat,k) flag=True cnt=1 while flag: flag=False # 循环遍历每个数据点 for i in range(m): bestDis=inf bestIndex=-1 # 循环遍历每个簇心，寻找距离最短的 for j in range(k): dis=calDis(dataMat[i],centroids[j]) if(dis\u003cbestDis): bestDis=dis bestIndex=j if(bestIndex!=clusterAssess[i][0]):flag=True clusterAssess[i]=[bestIndex,bestDis**2] # 重新计算簇心坐标 for i in range(k): filterDataMat=dataMat[clusterAssess[:,0]==i] centroids[i]=np.mean(filterDataMat,axis=0) plotDataSet(dataMat,cnt,centroids,clusterAssess) cnt+=1 return centroids,clusterAssess   下面是main测试函数（会生成每次训练结果的图片保存至代码目录下，testSet在github上）\n1 2 3 4 5 6  dataMat=loadDataSet(\"testSet.txt\") #calDist(dataMat[0],dataMat[1]) centroids=randCent(dataMat,4) #print(centroids) plotDataSet(dataMat,0) centroids,clusterAssess=KMeans(dataMat,4)   最终训练结果如下图：\n  性能度量 聚类性能度量大致有两种：\n  外部指标——将聚类结果与某个参考模型进行比较\n  内部指标——直接考察聚类结果而不适用任何参考模型\n  我们在这选用的是SSE（误差平方和）指标来度量\n$J=\\sum_{i=1}^{m}dis(x_i,c_{cluster[i]})(cluster[i]表示x_i所属的簇)$\n其中的dis可以采取欧式距离，曼哈顿距离或者加权距离，此处选取的为欧式距离的平方（为了更加重视远离中心的点）\n1 2  def costJ(clusterAssess): return np.sum(clusterAssess[:,1])   细节探讨 介绍完k-means的基本工作流程，下面还有几个具体算法实现的细节处理部分。\n选取原始簇心位置 我们来看一个原始簇心随机的不那么好的例子。\n训练前：\n训练后：\n可以看到，当原始随机的簇心落在图上的情况时，训练后的结果并不是我们预期的那样，且训练前后的结果相差不大。这是由于在一开始收敛时就陷入了局部最优解，从而无法收敛到全局最优解。\n因此，为解决这一问题，我们可以将随机初始化多执行几次来避免一次随机恰好陷入局部最优解的尴尬或者采取一种名为二分k-means的改进算法（通过开始将所有样本点归于一个簇类来避免随机，之后每次选取划分后SSE减小最大的一个簇进行k=2的k-mean分割直到满足所需的簇类为止）。\n确定k的大小 先让我们看一个例子来明白确定k（聚类数量）的大小意义。\n你是一个衣服店的老板，你需要根据手头上已有的顾客身高体重信息来确定T-shirt的尺码定制。\n很显然，我们需要确定一个合适的聚类数量来满足大多数顾客的需求以及避免过多的尺寸供过于求产生浪费。\n那么，我们可以通过训练不同的k后，比较SSE指标的大小，利用“肘部法则”来确定合适的聚类数量。\n如左图，显然k=3是图中的一个拐点，（形如人的肘部，因此称为肘部算法）k从2到3带来的性能提升是很大的,但是从3到4就没有这么明显了。（毕竟分的类越多，SEE肯定越小）。因此，为了减少成本，我们就可以选取3类尺码作为我们的T-shirt尺寸。\n当然，并不是所有的情况下我们都能得到左图，也有部分情况下得到的是右图（此时需要换个方法来求解）。\n总结 k-means作为聚类入门的基本算法，其原理简单，容易实现。但同时也有着k值很难确定，聚类效果依赖于聚类中心的初始化，容易陷入局部最优等缺点。\n同时除了k-means算法，聚类还有基于层次聚类的AGNES算法等，故这篇文章仅仅作为聚类入门来使用。\nRefences  哈林顿李锐. 机器学习实战 : Machine learning in action[M]. 人民邮电出版社, 2013. 周志华. 机器学习 : = Machine learning[M]. 清华大学出版社, 2016. 吴恩达 机器学习入门视频  ","description":"","tags":["python","无监督","聚类"],"title":"K-Means","uri":"/posts/k-means/"},{"categories":["机器学习"],"content":"问题引入 如上图，我们将每个点看成一个样本，$x_1,x_2$为样本的两个特征。可以看到所有点都可划分为class0或class1。（本文只讨论二分类问题）\n当我们要对一个新的样本进行分类，可以采用回归预测的方法。也就是拟合一个假设函数$h_\\theta(x)$,该函数以样本的所有特征为参数，返回该样本的类别。但是，对于一个分类的问题，常规的回归预测并不适用，因为我们经过假设函数$h_\\theta(x)$预测往往返回的是一个连续值，但对于样本而言，其标签非0即1，是一个离散值。所以，就有了一种用于分类的回归算法logistic。\n在继续阅读前，希望您已经有了线性回归和梯度下降法的基础。\n本篇文章相关代码以及数据集已上传至github\n假设函数 我们一般定义$h_\\theta(x)$=$\\theta_0+\\theta_1\\times x_1+\\theta_2\\times x_2+...+\\theta_n\\times x_n$ (别问为什么这么定义，问就是奥卡姆剃刀)\n我们的最终目的，就是去拟合参数$\\theta=[\\theta_0,\\theta_1...\\theta_n]^T$来提升分类器的性能。\n对于一个分类问题而言，我们需要设定阈值来比较样本与阈值的大小进行分类。但是对于这个朴素的$h_\\theta(x)$,返回值本身没有意义且阈值较难设定。所以从某种角度上来说，我们希望$h_\\theta(x)$的返回值有意义，比如表示该样本属于class0的概率，那就要求$h_\\theta$的值域为$[0,1]$，这样当$h_\\theta(x)$\u003e0.5时，我们将其分类为class0，当\n$h_\\theta(x)$\u003c0.5时，我们将其分类为class1.于是，大佬们就找到了一种函数sigmoid。\nsigmoid sigmoid函数原型为$g(z)=\\frac{1}{1+e^{-z}}$\n该函数有良好的特性适应我们的需求。\n  其定义域为$(-\\infty,+\\infty)$,相应的其值域为$(0,1)$，正好满足概率分布的要求。\n  它是单调上升的函数，具有良好的连续性，不存在不连续点。而且由于$g(0)=0.5$因此可以选取0作为分界点。\n  因此将原来的$h_\\theta(x)=\\theta^Tx$作为sigmoid函数的输入，得到\n$h_\\theta(x)=g(\\theta^Tx)=\\frac{1}{1+e^{-\\theta^Tx}}$\n好了，确定了假设函数的形式，接下来的任务就是如何通过样本数据来拟合参数$\\theta$.\n代价函数 在来拟合参数前，我们先来讲讲如何我们对函数拟合好坏的评价标准。我们的方法是设计一个代价函数。\n$J(\\theta)=\\frac{1}{m}\\sum_{i=1}^{m}\\frac{1}{2}(h_\\theta(x^i)-y^i))^2$\n这是普通线性回归中会用到的代价函数$Cost(h_\\theta(x),y)=\\frac{1}{2}(h_\\theta(x)-y))^2$\n但是由于logistic中的$h_\\theta(x)$的是一个很复杂的函数，且非凸，\n会有很多局部最小值，我们如果还是采取这个函数为代价函数，在使用梯度下降法时就无法保证收敛至全局最小值。所以，针对logistic回归，我们需要设计一种新的代价函数。\n$Cost(h_\\theta(x),y)=\\begin{cases}-log(h_\\theta(x)), \u0026 \\text{if $y$ = 1} \\ -log(1-h_\\theta(x)), \u0026 \\text{if $y$ = 0}\\end{cases}$\n如图这两个函数当输入在趋于0或1时都表现的很好，例如当实际$y=1$时，如果$h_\\theta(x)=1$，完全预测正确，那么代价值就为0，反之若$h_\\theta(x)=0$，完全预测错误，那么代价就会趋向于无穷。\n同时代价函数可以简化为$Cost(h_\\theta(x),y)=-y\\times log(h_\\theta(x))-(1-y)\\times log(1-h_\\theta(x))$\n所以$J(\\theta)=\\frac{1}{m}\\sum_{i=1}^{m}Cost(h_\\theta(x^i),y^i)$\n​\t$=-\\frac{1}{m}(y^i\\times log(h_\\theta(x^i))+(1-y^i)\\times log(1-h_\\theta(x^i)))$\n这就是logistic的代价函数了，由于该函数为凸函数，我们就可以使用梯度下降法来求取最优解了。\n梯度下降法 众所周知，梯度下降法的更新公式为$\\theta=\\theta- \\alpha\\times\\frac{\\partial J(\\theta)}{\\partial\\theta}$\n其中，$\\alpha$为我们设置的学习率。\n那么，代入logistic的$J(\\theta)$,得到\n$\\theta_j=\\theta_j-\\alpha\\sum_{i=1}^m(h_\\theta(x^i)-y^i)x_j^i$\n$=\\theta_j+\\alpha\\sum_{i=1}^m(y^i-h_\\theta(x^i))x_j^i$\n令m表示样本数,n表示特征数\n向量化，得到$\\theta_{n\\times1}=\\theta_{n\\times1}-\\alpha x^T_{n*m}\\times(h(x)_{m*1}-y_{m*1})$\n有了公式，我们就能写出代码了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import numpy as np def sigmoid(x): return 1.0/(1+np.exp(-x)) def gradAscent(dataMatIn,labelMatIn): # dataMat为m*n的样本矩阵 # labelMat为m*1的标签矩阵 dataMat=np.mat(dataMatIn) labelMat=np.mat(labelMatIn).transpose() alpha=0.001 maxCycles=500 # weights(代求参数)初始化为n*1的矩阵 weights=np.ones((dataMat.shape[1],1)) # 进行maxCycles次迭代 for i in range(maxCycles): # h为m*1矩阵,每行表示h(x) h=sigmoid(dataMat*weights) error=labelMat-h weights=weights+alpha*dataMat.transpose()*error # 将weights转换为array返回 return weights.getA()   接下来让我们画出分界曲线来直观的感受一下拟合的好坏吧。\n由sigmoid函数可知分界点$h_\\theta(x)=0.5$\n$\\theta^Tx=0$\n在这个测试集上，得到 $\\theta_0+\\theta_1x_1+\\theta_2x_2=0$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  # plotDataSet 画出原始的散点图 def plotDataSet(): dataMat,labelMat=loadDataSet() x0_set=[];y0_set=[];x1_set=[];y1_set=[] for i in range(len(dataMat)): if(labelMat[i]): x1_set.append(dataMat[i][1]);y1_set.append(dataMat[i][2]) else: x0_set.append(dataMat[i][1]);y0_set.append(dataMat[i][2]) fig,ax=plt.subplots() ax.scatter(x0_set,y0_set,color='green',label='class0') ax.scatter(x1_set,y1_set,color='red',label='class1') ax.set_xlabel('X1') ax.set_ylabel('X2') ax.legend() return fig,ax # plotfit 在原始散点图上添加拟合直线 def plotfit(weights): fig,ax=plotDataSet() x=np.arange(-3,3,0.1) y=(-weights[0]-weights[1]*x)/weights[2] ax.plot(x,y) plt.show() weights=gradAscent(dataMat,labelMat) plotfit(weights)   得到下图\n可以看到，拟合的还算不错。\n但是这样的梯度下降法存在一个问题:效率过低。因为每进行一次迭代，其都需要对整个样本数据集进行矩阵操作，像我们使用的数据集中只有几百个样本和较少的特征。但是当我们碰到成千上万个样本以及较多的特征时，梯度下降法的效率就不足以支撑我们处理这些数据了。\n因此为解决效率问题，下面介绍一种随机梯度下降法。\n随机梯度下降法（SGD） 随机梯度下降法本质上和批量梯度下降一样，唯一的区别在于每次更新时随机选取数据集中的一个样本进行更新，而不是遍历整个数据集再进行更新，这样就大大降低了算法的时间复杂度。但是，带来的代价就是准度会降低，由于是随机选取一个进行更新，没有考虑全局，就像在黑暗中盲目摸索，无法保证每次更新都是朝着正确的方向，所以相比批量梯度下降的准确率肯定会下降。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import random def stocGradAscent(dataMat,labelMat,maxCycles=10): m,n=np.shape(dataMat) weights=np.ones(n) for i in range(maxCycles): # 创建一个用于随机选取的列表 dataIndex=list(range(m)) for j in range(m): alpha=4/(1.0+j+i)+0.01 # 随机选取一个样本 randindex=int(random.uniform(0,len(dataIndex))) h=sigmoid(sum(dataMat[randindex]*weights)) error=labelMat[randindex]-h weights=weights+alpha*error*dataMat[randindex] # 删除选取的样本序号 del(dataIndex[randindex]) return weights weights=stocGradAscent(np.array(dataMat),labelMat,10) plotfit(weights)   效果如下：\n可以看到，SGD算法和BGD算法内循环的时间复杂度是一样的，但是SGD只需要大迭代10次就能达到BGD迭代500次的效果，原因就在于SGD每次随机选取一个样本计算代价后就对参数进行了更新。\n使用logistic回归预测病马的死亡率 我们先来看一下数据集：\n该数据集中有很多缺失值，一般对于数据集有缺失的值，有几种做法：\n  使用可用特征的均值来填补缺失值\n  使用特殊值来填补确实值 如-1\n  忽略有缺失值的样本\n  使用相似样本的均值添补缺失值\n  使用另外的机器学习算法预测缺失值\n  所以在预处理阶段我们可以使用0来代替所有缺失值，因为在logistic回归中，如果某个特征值为0，应用该更新公式:$weights=weights+\\alpha\\times error \\times dataMat[i]$,$weights$将不会得到更新。\n然后我们在看一下各个特征属性，显然第3行的医院编号对病马的死亡率是没有影响的，所以我们将这行去掉。同时我们将所有特征属性归一化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  import pandas as pd import numpy as np from sklearn.preprocessing import StandardScaler def loadData(filename): df=pd.read_csv(filename,header=None,delimiter=\"\\s+\") df=df.replace('?',0.0) x=df.iloc[:,np.r_[0:2,3:26]] y=df.iloc[:,-1] # 进行特征值归一化 ss=StandardScaler() x=ss.fit_transform(x) return x,y x_train,y_train=loadData('horse-colic.data') x_test,y_test=loadData('horse-colic.test')   预处理完成，我们使用logistic回归进行一下预测，这里我直接使用sklearn的logistic回归算法（偷个懒）。\n1 2 3 4  from sklearn.linear_model import LogisticRegression classifier=LogisticRegression(solver='liblinear',max_iter=500).fit(x_train,y_train) test_accury=classifier.score(x_test,y_test) print(f'准确率为{test_accury}')   结果如下：\n准确率为0.8382352941176471 ","description":"","tags":["python","logistic","分类"],"title":"logistic回归","uri":"/posts/logistic%E5%9B%9E%E5%BD%92/"},{"categories":["机器学习"],"content":"前置知识 条件概率 我们规定$P(c)$代表事件c发生的概率(先验概率)\n$P(x|c)$代表在事件c发生的前提下，事件$x$发生的概率。此时的$P(x|c)$就是最简单的条件概率。\n先给出两者的计算公式。\n令$D_c$表示训练集D中第c类样本的集合，令$D_{c,x_i}$表示$D_c$中第i个属性为$x_i$的样本的集合。当样本数量足够大的时候，可以估计出\n$P(c)=\\frac{|D_c|}{|D|}$\n$P(x_i|c)=\\frac{|D_{c,x_i}|}{|D_c|}$\n同时根据这两个公式我们推出$P(x|c)=\\frac{P(x,c)}{P(c)}$\n让我们用最熟悉的🍉数据集举个例子:\n首先估计先验概率$P(c)$，显然有\nP(好瓜=是)=$\\frac{8}{17}$ P(好瓜=否)=$\\frac{9}{17}$\n然后再为每个属性估计条件概率$P(x_i|c)$(举色泽的例子)\n例如我们要求P(青绿|是)，根据条件概率的定义，就相当于在好瓜里挑出色泽为青绿的瓜，总共有3个，好瓜又只有8个，所以P(青绿|是)=$\\frac{3}{8}$\n同理P(乌黑|否)=$\\frac{2}{8}$\n朴素贝叶斯理论 当我们拿到一个陌生的数据，例如一个西瓜={青绿，蜷缩，浊响，清晰，凹陷，硬滑，密度0.697，含糖0.460}（记该属性组合为$w$)，我们需要分类其是否为好瓜。一种可行的方法是计算出P(w,是)和P(w,否)的概率，比较大小，哪个大就属于哪个类别。这就是贝叶斯决策理论。\n普通的讲，贝叶斯决策理论要求计算两个概率p1(x, y)和p2(x, y)：\n如果p1(x, y) \u003e p2(x, y)，那么属于类别1；\n如果p2(x, y) \u003e p1(x, y)，那么属于类别2。\n回到那个西瓜的问题，我们其实无法直接求出P(w,是)的大小（因为这是一个全新的样本），但是根据刚刚条件概率的公式$P(x|c)=\\frac{P(x,c)}{P(c)}$，我们可以得出P(w,是)=P(是)$\\times$P(w|是)。P(是)容易得到，那么P(w|是)呢？当|w|=1时，我们也容易得到，那么当$|w|\u003e1$时，容易想到概率论中$P(w|c)=\\prod_{i=1}^{|w|}P(w_i|c)$\n但这个公式成立的前提是$w_i$相互独立无关。那么当我们运用朴素贝叶斯时，特征之间是否相互无关呢？其实大多情况下特征之间都有着一定的联系，但是朴素贝叶斯分类器的假设就是特征之间相互独立且同等重要。这就是朴素贝叶斯中朴素一词的由来。因此，我们可以使用这个公式来求解。例如上文中的陌生西瓜，\nP(w,是)=P(是)$\\times$P(青绿|是)$\\times$P(蜷缩|是)$\\times$P(浊响|是)$\\times$P(清晰|是)$\\times$P(凹陷|是)$\\times$P(硬滑|是)$\\times$P(密度0.697|是)$\\times$P(含糖0.460|是)=0.052\nP(w,否)=P(否)$\\times$P(青绿|否)$\\times$P(蜷缩|否)$\\times$P(浊响|否)$\\times$P(清晰|否)$\\times$P(凹陷|否)$\\times$P(硬滑|否)$\\times$P(密度0.697|否)$\\times$P(含糖0.460|否)=0.000068\n因此该西瓜样本经过朴素贝叶斯分类为好瓜。\n至此朴素贝叶斯基本原理就介绍完毕了，接下来就进入代码实现部分吧。\n代码实现 文本分类目标 给定论坛上的一些留言样本，每个留言有两种标签，正常语言和侮辱性语言。（1代表侮辱性文字，0代表正常语言），要求通过朴素贝叶斯分类器训练数据后，能对新的留言进行分类。\n数据预处理 loadDataSet:创建训练数据\ndataset:训练文档\nclassVec:文档依次对应标签(0表示文明/1表示不文明)\n1 2 3 4 5 6 7 8 9 10 11 12 13  def loadDataSet(): dataset=[['my','dog','has','flea', 'problems','help','please'], ['maybe','not','take','him', 'to','dog','park','stupid'], ['my','dalmation','is','so','cute', 'I','love','him'], ['stop','posting','stupid','worthless','garbage'], ['my','licks','ate','my','steak','how', 'to','stop','him'], ['quit','buying','worthless','dog','food','stupid']] classVec=[0,1,0,1,0,1] return dataset,classVec   createVocab:创建词汇表\ntrainData:训练文档\nVocab:由训练文档中所有单词组成的词汇表\n1 2 3 4 5 6  def createVocab(trainData): Vocab=set([]) for document in trainData: Vocab=Vocab|set(document) return list(Vocab) VocabList=createVocab(trainData)   createWordsVec:将inX转换成词向量\nVocabList:创建好的词汇表\ninX:需要转换的文档\n1 2 3 4 5 6  def createWordsVec(VocabList,inX): outX=[0]*len(VocabList) for word in inX: if(word in VocabList): outX[VocabList.index(word)]+=1 return outX   上述的三个函数作用是载入训练数据并将原来的文档转换为一个统一的矩阵，矩阵每一行代表一条留言，这条留言的词向量每一元素表示该单词出现的次数。这种表示方法采用的是词袋模型，区别于词集模型（只表示该次是否出现在文档中）。\n这样我们就将原来的训练数据转换成一个文档矩阵，便于后面的运算操作。\n训练函数 基于上面的理论，我们需要求出所有在文档中出现过的词汇$w$的$P(w|0)$和$P(w|1)$.\n根据$P(w|0)=\\frac{P(w,0)}{P(0)}$和$P(w|1)=\\frac{P(w,1)}{P(1)}$,可以设计出最初版本\nbayesTrain:训练朴素贝叶斯分类器\ntrainMat:将训练文档转换为词向量组成的矩阵\ntrainclass:训练文档对应的标签\np0v:p(w|0)组成的向量\np1v:p(w|1)组成的向量\npAbusive:文档属于侮辱类的概率\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  import numpy as np def bayesTrain(trainMat,trainclass): n=len(trainMat[0]) pAbusive=sum(trainclass)/len(trainMat) p0v=np.zeros(n) p1v=np.zeros(n) sum0=sum1=0 for i in range(len(trainMat)): if(trainclass[i]): p1v+=trainMat[i] sum1+=sum(trainMat[i]) else: p0v+=trainMat[i] sum0+=sum(trainMat[i]) p0v=p0v/sum0 p1v=p1v/sum1 return p0v,p1v,pAbusive trainMat=[] for document in trainData: trainMat.append(createWordsVec(VocabList,document)) p0v,p1v,pAbusive=bayesTrain(trainMat,trainclass)   代码优化 在实现函数的时候我们会碰到两个问题：\n  如果待分类的数据中出现了词汇表中没有出现过的单词$w_i$，那么其$P(w_i|0)$和$P(w_i|1)$均为0,导致最终结果连乘也为0。显然这与现实是不符的。\n  另一个问题是下溢出，这是由于太多很小的数相乘造成的。当计算乘积$\\prod_{i=1}^{|w|}P(w_i|c)$ 时，由于大部分因子都非常小，所以程序会下溢出或者 得到不正确的答案。（读者可以用Python尝试相乘许多很小的数，最后四舍五入后会得到0）\n  拉普拉斯平滑 针对问题1出现的零概率，法国数学家拉普拉斯最早提出用加1的方法估计没有出现过的现象的概率。具体来说，令N表示训练集中D中可能的类别数，$N_i$表示第$i$个属性可能的取值数，则原来的公式可以修正为$P(c)=\\frac{|D_c|+1}{|D|+N}$\n$P(x_i|c)=\\frac{|D_{c,x_i}|+1}{|D_c|+N_i}$\n对原来的代码作如下修改：\n1 2 3  p0v=np.ones(n) p1v=np.ones(n) sum0=sum1=n   对数优化 针对问题2，由于$lnx$和$x$单调性相同，且$ln(a*b)=lna+lnb$。所以在实践中常通过取对数的方式将连乘转化为连加以避免数值下溢。\n对原来的代码作如下修改：\n1 2  p0v=np.log(p0v/sum0) p1v=np.log(p1v/sum1)   最终版本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  import numpy as np def bayesTrain(trainMat,trainclass): n=len(trainMat[0]) pAbusive=sum(trainclass)/len(trainMat) p0v=np.ones(n) p1v=np.ones(n) sum0=sum1=n for i in range(len(trainMat)): if(trainclass[i]): p1v+=trainMat[i] sum1+=sum(trainMat[i]) else: p0v+=trainMat[i] sum0+=sum(trainMat[i]) p0v=np.log(p0v/sum0) p1v=np.log(p1v/sum1) return p0v,p1v,pAbusive trainMat=[] for document in trainData: trainMat.append(createWordsVec(VocabList,document)) p0v,p1v,pAbusive=bayesTrain(trainMat,trainclass)   分类预测 1 2 3 4 5 6 7 8 9 10 11 12  def classify(inX,p0v,p1v,pclass1): p1=sum(inX*p1v)+log(pclass1) p0=sum(inX*p0v)+log(1-pclass1) if(p1\u003ep0): return 1 else: return 0 test=[['love','my','dalmation'], ['stupid','garbage']] for document in test: label=classify(createWordsVec(VocabList,document),p0v,p1v,pAbusive) print(f\"{','.join(document)}classified as :{label}\")   运行结果如下： 可以看到test中的预测结果都是正确的。\n总结 朴素贝叶斯有着如下优点和缺点：\n优点   朴素贝叶斯模型发源于古典数学理论，有着坚实的数学基础，以及稳定的分类效率；\n  对大数量训练和查询时具有较高的速度。即使使用超大规模的训练集，针对每个项目通常也只会有相对较少的特征数，并且对项目的训练和分类也仅仅是特征概率的数学运算而已；\n  对小规模的数据表现很好，能个处理多分类任务，适合增量式训练（即可以实时的对新增的样本进行训练）；\n  对缺失数据不太敏感，算法也比较简单，常用于文本分类；\n  缺点   由于使用了样本属性独立性的假设，所以如果样本属性有关联时其效果不好。\n  对输入数据的表达形式很敏感，需要使用标称性数据\n  应用领域  文本分类 垃圾邮件过滤 情感判别  ","description":"","tags":["python","贝叶斯"],"title":"朴素贝叶斯","uri":"/posts/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"},{"categories":["机器学习"],"content":"问题引入 试想一下有一些海洋动物，它们有2个特征：1.不浮出海面是否可以生存 2.是否有脚蹼\n根据这些特征我们可以将这些海洋动物分为2类（1，2和3，4，5）。显然是否属于鱼类和它们的各个特征之间是有联系的，就如上的数据而言，我们发现只要第一项特征为否就一定不属于鱼类，在第一项特征为是的情况下，还要根据第二项来判断是否为鱼类。根据这个简单的决策关系，我们可以做出一个简单的决策树。\n那么当我们要去解决一个陌生领域的问题时，只要我们有大量的样本数据，就能通过决策树算法合理划分数据集，从而对一个全新的数据作出判断分类。现实中一些优秀的决策树往往能媲美在该领域中工作了十几年的专家。\n前置芝士 信息熵 可以看出在决策树的建立过程中选取哪个特征进行划分是关键。信息熵就是衡量选取特征好坏的方式之一。\n何为信息熵？给个通俗的理解，大家都知道小明cpp课平时在睡觉。期末考试发生了以下两种情况。\nA. 小明的cpp课挂科了。\nB. 小明的cpp课拿到了90分的高分。\n那么对于A事件，大家并不惊讶，这件事带来的信息熵就小；而对于B事件，显然大家都是没意料到的，这件事的信息熵就大。所以决策树里的信息熵就是我们通过划分数据集使数据集变得有序带来的信息增益。那么信息增益当然是越大越好。\n设一件事情发生的概率为$p(x_i)$，所包含的信息为$l(x_i)$。\n$$l(x_i)=-log_2p(x_i)$$\n那么对于一个有不同标签的数据集而言，它的熵就需计算所有类别所有可能值所包含的信息总和。\n$$H=-\\sum_{i=1}^{n}p(x_i)log_2p(x_i)$$\n1 2 3 4 5 6 7 8 9 10 11  def calcEnt(dataSet): #计算给定数据集的熵 numEnts=len(dataSet) #数据集中实例的总数 labels={} for featvec in dataSet: #为所有可能分类创建字典 curlabel=featvec[-1] labels[curlabel]=labels.get(curlabel,0)+1 Ent=0 for key in labels: # l(xi)=-log2p(xi)计算熵 prob=labels[key]/numEnts Ent-=prob*log2(prob) return Ent   划分数据集 我们知道了如何计算给定数据集的信息熵，接下来就可以来选取划分属性了。\n思路很简单：遍历所有的特征，计算出选取该特征作为划分依据时所得到的信息熵，从中选取最大的就好了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  def splitDataSet(dataSet,axis,value): #根据axis来划分dataSet,返回去掉axis的dataset retDataSet=[] for featvec in dataSet: if(featvec[axis]==value): reducedfeatvec=featvec[:axis] reducedfeatvec.extend(featvec[axis+1:]) #去掉axis维 retDataSet.append(reducedfeatvec) return retDataSet def choseBestfeat(dataSet): #选取最好的划分属性 numfeat=len(dataSet[0])-1 baseEnt=calcEnt(dataSet) #未划分数据集的熵 bestInfoGain=0 for i in range(numfeat): #依次选取不同的属性作为划分依据 featlist=[value[i] for value in dataSet] featlist=set(featlist) #提取当前属性的所有value Ent=0 for value in featlist: #计算划分数据集后的熵 subdataSet=splitDataSet(dataSet,i,value) prob=len(subdataSet)/len(dataSet) Ent+=prob*calcEnt(subdataSet) if(baseEnt-Ent\u003ebestInfoGain): #求出信息增益最大时的属性 bestInfoGain=baseEnt-Ent bestfeat=i return bestfeat   构建决策树 准备工作都做完了，接下来到重头戏了，如何构建一个决策树。\n1.选取信息熵最大的特征来划分数据集\n2.所有特征都已经用作划分的依据或者每个分支下的所有实例都已经具有相同的分类\n3.若满足2，退出 ；若不满足2，回到1继续划分\n这就是递归构造决策树的过程。（这里树的存储是采用了python中的字典嵌套。）\nmaxclasscnt函数返回的是一个列表当中最多的class，目的是处理所有属性都已经遍历完，但依然有分支下的所有实例不具有相同的标签，因此只能多数代表少数（这也是决策树会判断失误的例子）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  def maxclasscnt(classlist): #返回classlist中最多的class classcnt={} for label in classlist: classcnt=classcnt.get(label,0)+1 sortedclasscnt=sorted(classcnt.items,key=operator.itemgetter(1),reverse=False) return sortedclasscnt[0][0] def createTree(dataSet,labels): classlist=[example[-1] for example in dataSet] if(classlist.count(classlist[0])==len(classlist)): #当前的dataset已经类别相同，直接返回 return classlist[0] if(len(dataSet[0])==1): #所有的属性都已经遍历完，返回最多的class return maxclasscnt(classlist) bestfeat=choseBestfeat(dataSet) sublabels=labels[:] bestlabel=sublabels[bestfeat] mytree={bestlabel:{}} #字典嵌套建树,构建根节点 del(sublabels[bestfeat]) #删除已经作为分类依据的属性 featvalue=[example[bestfeat] for example in dataSet] #儿子节点可能的值 featvalue=set(featvalue) for value in featvalue: #递归建树(分别将划分好的数据集作为儿子节点) mytree[bestlabel][value]=createTree(splitDataSet(dataSet,bestfeat,value),sublabels) return mytree   构建完后让我们来测试一下：\n1 2 3 4 5 6 7 8 9 10  def createDataSet(): dataSet=[[1,1,\"yes\"], [1,1,\"yes\"], [1,0,\"no\"], [0,1,\"no\"], [0,1,\"no\"]] labels=[\"no surfacing\",\"flippers\"] #每个样本的2个属性 return dataSet,labels dataSet,labels=createDataSet() mytree=createTree(dataSet,labels)   如果一切正常的话，得到的mytree应该是这样子的：\n{'no surfacing': {0: 'no', 1: {'flippers': {0: 'no', 1: 'yes'}}}}\r这个样子的树看起来很抽象对不对，等会我们就用matplob来绘制树的图。\n下面我们先写一个输入新的数据时 分类的函数\n1 2 3 4 5 6 7 8 9 10  def classify(inputTree,featlabels,testVec): # 利用决策树分类 root=list(inputTree.keys())[0] son=inputTree[root] featindex=featlabels.index(root) # 找到对应特征向量的索引 for key in son.keys(): if(testVec[featindex]==key): if(type(son[key]).__name__=='dict'): #如果下面还有儿子 classlabel=classify(son[key],featlabels,testVec) else: classlabel=son[key] return classlabel   ","description":"","tags":["python","决策树"],"title":"决策树","uri":"/posts/%E5%86%B3%E7%AD%96%E6%A0%91/"},{"categories":["机器学习"],"content":"K-近邻算法 原理 入坑学的第一个算法，理论看不懂的我直接来实战了（枯）\n其实k-近邻算法（以下简称knn）的原理蛮简单的。\n比如说现在有一个训练样本集，并且都有标签。当我们遇到一个未标签过的新数据时，将新数据与每个已有的样本进行特征比较，然后选择其中特征差异最小的前k个，最后选择这k个相似数据中出现最多的标签作为新数据的标签。（通常$k\u003c20$）\n一句话概括其实就是谁近选谁。\nk-近邻算法的一般流程   收集数据：可以使用任何方法。\n  准备数据：距离计算所需要的数值，最好是结构化的数据格式。\n  分析数据：可以使用任何方法。\n  训练算法：此步骤不适用于k-近邻算法。\n  测试算法：计算错误率。\n  使用算法：首先需要输入样本数据和结构化的输出结果，然后运行k-近邻算法判定输 入数据分别属于哪个分类，最后应用对计算出的分类执行后续的处理。\n​\t——转自《机器学习实战》\n  算法实现 对未知类别属性的数据集中的每个点依次执行以下操作：\n 计算已知类别数据集中的点与当前点之间的距离； 按照距离递增次序排序； 选取与当前点距离最小的k个点； 确定前k个点所在类别的出现频率； 返回前k个点出现频率最高的类别作为当前点的预测分类。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  from numpy import * import operator def createDataSet(): group=array([[1.0,1.1],[1.0,1.0],[0,0],[0,0.1]]) labels=['A','A','B','B'] return group,labels def classify0(inX,dataSet,labels,k): #计算新数据与每个点的距离 dataSetSize=dataSet.shape[0] diffMat=tile(inX,(dataSetSize,1))-dataSet sqDiffMat=diffMat**2 sqDistances=sqDiffMat.sum(axis=1) distances=sqDistances**0.5 #argsort返回下标 sortedDistances=distances.argsort() classcount={} #统计前k个group的label出现次数 for i in range(k): voteIlabel=labels[sortedDistances[i]] classcount[voteIlabel]=classcount.get(voteIlabel,0)+1 sortedclasscount=sorted(classcount.items(),key=operator.itemgetter(1),reverse=True) return sortedclasscount[0][0]   测试方法： 进入到包含这个KNN.py的文件夹的python工作模式下，运行\n1 2 3  import KNN group,label=KNN.createDataSet() KNN.classify0([0,0],group,label,3)   得到的结果为“B”标签\n海伦约会： 训练集：海伦约会过的人属性特性以及海伦对他们的喜欢程度\n训练方法：knn\n归一特征值处理：由于属性之间无法横向比较，将三个属性的特征值差都归一为[0,1]之间\n训练误差（错误率）：5%\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111  from numpy import * # 导入科学计算包 from matplotlib.font_manager import FontProperties import matplotlib.lines as mlines import matplotlib.pyplot as plt # 导入绘图工具包 import operator # 导入运算符模块 def file2matrix(filename): #读取文本数据 fr = open(filename) # 打开文件 arrarOLines = fr.readlines() # 读取内容 numberOfLines = len(arrarOLines) # 解析有多少行 returnMat = zeros((numberOfLines, 3)) # 创建行数*3的矩阵，以0填充 classLabelVector = [] index = 0 for line in arrarOLines: line = line.strip() # 删除空白字符 listFromLine = line.split('\\t') # 以空格来分割 returnMat[index, :] = listFromLine[0:3] # 前三位放入矩阵 classLabelVector.append(listFromLine[-1]) # 最后一位存入标签 index += 1 return returnMat, classLabelVector def showData(datingDataMat, datingLabels): #绘制散点图 font = FontProperties('SimHei') #设置字体为黑体 fig, ax = plt.subplots(nrows=2, ncols=2, sharex=False, sharey=False, figsize=(15, 10)) #将fig画布分为2*2四个区域，x轴和y轴不共享，每个画布13*8大小 LabelsColors = [] for i in datingLabels: if i == 'didntLike': #区分三种标签的颜色 LabelsColors.append('black') if i == 'smallDoses': LabelsColors.append('orange') if i == 'largeDoses': LabelsColors.append('red') \"\"\"左上角[0][0]\"\"\" ax[0][0].scatter(x=datingDataMat[:, 0], y=datingDataMat[:, 1], color=LabelsColors, s=15, alpha=.5) #设置x轴数据和y轴数据，颜色，圆点大小，透明度 ax00_title = ax[0][0].set_title(u'每年获得的飞行常客里程数与玩视频游戏所消耗时间占比', FontProperties=font) #设置标题和字体 ax00_xlabel = ax[0][0].set_xlabel(u'每年获得的飞行常客里程数', FontProperties=font) ax00_ylabel = ax[0][0].set_ylabel(u'玩视频游戏所消耗时间占比', FontProperties=font) plt.setp(ax00_title, size=10, weight='bold', color='red') #设置图例 plt.setp(ax00_xlabel, size=8, weight='bold', color='black') plt.setp(ax00_ylabel, size=8, weight='bold', color='black') \"\"\"右上角[0][1]\"\"\" ax[0][1].scatter(x=datingDataMat[:, 0], y=datingDataMat[:, 2], color=LabelsColors, s=15, alpha=.5) ax01_title = ax[0][1].set_title(u'每年获得的飞行常客里程数与每周消费的冰激淋公升数', FontProperties=font) ax01_xlabel = ax[0][1].set_xlabel(u'每年获得的飞行常客里程数', FontProperties=font) ax01_ylabel = ax[0][1].set_ylabel(u'每周消费的冰激淋公升数', FontProperties=font) plt.setp(ax01_title, size=10, weight='bold', color='red') plt.setp(ax01_xlabel, size=8, weight='bold', color='black') plt.setp(ax01_ylabel, size=8, weight='bold', color='black') \"\"\"左下角[1][0]\"\"\" ax[1][0].scatter(x=datingDataMat[:, 1], y=datingDataMat[:, 2], color=LabelsColors, s=15, alpha=.5) ax10_title = ax[1][0].set_title(u'玩视频游戏所消耗时间占比与每周消费的冰激淋公升数', FontProperties=font) ax10_xlabel = ax[1][0].set_xlabel(u'玩视频游戏所消耗时间占比', FontProperties=font) ax10_ylabel = ax[1][0].set_ylabel(u'每周消费的冰激淋公升数', FontProperties=font) plt.setp(ax10_title, size=10, weight='bold', color='red') plt.setp(ax10_xlabel, size=8, weight='bold', color='black') plt.setp(ax10_ylabel, size=8, weight='bold', color='black') didntLike = mlines.Line2D([], [], color='black', marker='.', markersize=6, label='didntLike') smallDoses = mlines.Line2D([], [], color='orange', marker='.', markersize=6, label='smallDoses') largeDoses = mlines.Line2D([], [], color='red', marker='.', markersize=6, label='largeDoses') ax[0][0].legend(handles=[didntLike, smallDoses, largeDoses]) #添加图例 ax[0][1].legend(handles=[didntLike, smallDoses, largeDoses]) ax[1][0].legend(handles=[didntLike, smallDoses, largeDoses]) plt.show() #显示图表 def autonorm(dataSet): #归一化特征值 newvalue=(oldvue-minvals)/(maxvals-minvals) [0,1] minvals=dataSet.min(0) #从列中选取最小值 maxvals=dataSet.max(0) ranges=maxvals-minvals normdata=dataSet-tile(minvals,(dataSet.shape[0],1)) normdata=normdata/tile(ranges,(dataSet.shape[0],1)) return normdata def classify0(inx,dataSet,labels,k): #原始分类器 diffmat=tile(inx,(dataSet.shape[0],1))-dataSet diffmat=diffmat**2 dismat=diffmat.sum(axis=1) #axis=0(默认)矩阵按列相加 axis=1 矩阵按行相加 dismat=dismat**0.5 #计算距离 sorteddismat=dismat.argsort() #argsort()默认从小到大排序，返回下标 count_class={} for i in range(k): label=labels[sorteddismat[i]] count_class[label]=count_class.get(label,0)+1 sortedclasscount=sorted(count_class.items(),key=operator.itemgetter(1),reverse=True) #按label数量从小到大排序 return sortedclasscount[0][0] def datatest(): #测试错误率 datamat,labels=file2matrix(\"datingTestSet.txt\") normdata=autonorm(datamat) #归一特征值 m=normdata.shape[0] num_test=int(m*0.1) #测试数据占10% error_count=0 for i in range(num_test): #计算错误率 res_classify=classify0(normdata[i,:],normdata[num_test:m,:],labels[num_test:m],3) print(\"the classifier came back with %s,the real answer is %s\"%(res_classify,labels[i])) if(res_classify!=labels[i]): error_count=error_count+1 error_rate=error_count/num_test print(\"error_count is \",error_count) print(\"the total error rate is \",error_rate) return error_rate def classifperson(): # 最终预测器 games=float(input(\"please input the time of playing video games weekly:\")) fly=float(input(\"please input the flier miles yearly:\")) icecream=float(input(\"please input the icecream consumed yearly:\")) dataSet,labels=file2matrix(\"datingTestSet.txt\") res=classify0(array([games,fly,icecream]),dataSet,labels,3) print(\"You will probably like this person:\",res) return res classifperson()   ","description":"","tags":["python","kNN"],"title":"knn","uri":"/posts/knn/"},{"categories":["机器学习"],"content":"Linux和ubuntu 首先介绍一下Linux，大家想必都知道windows，和windows，Linux也是操作系统，相对于Windows而言， Linux是完全免费的，开放源码，为用户提供了最大限度的自由度。且Linux更加稳定更加安全，所以通常作为服务器的操作系统使用。\n那么，ubuntu是什么呢？ubuntu和Linux的关系，打个比方，就像是一系列手机厂商的EMUI，MIUI和Android的关系，ubuntu也是Linux众多发行版之中较流行的一个（据说适合入门） ，而且网上的教程也多，出现了问题也比较容易找到解决方案。\n该安装教程主要借鉴了原帖\nVirtualBox安装 相对于常用的VMware，VirtualBox可能更适合入门折腾。\nVirtualBox 官方下载\n点进去windows用户直接下载第一个就好\nUbuntu下载 两种渠道，第一种是官网下载（需要科学）\n第二种就是阿里云，腾讯云，清华镜像等提供的镜像下载\n我选择的使用阿里云，并且下载了20.04最新版\n虚拟机创建   打开VirtualBox，点击右上角的新建\n  选择Linux类型和ubuntu（64bit)版本\n  点击下一步进行内存大小和硬盘设置（按自己需求即可）\n  硬盘文件类型和存储均选择默认即可\n  最后确定文件存放位置以及硬盘的大小\n  Ubuntu20.04安装 在启动虚拟机前，还有一些设置要做\n  设置-存储-选择虚拟盘（刚刚下好的ubuntu桌面版64bit）\n  设置-网络-网卡1-连接方式选择桥接网卡（不然主机无法访问虚拟机）\n  启动虚拟机，安装过程中选择中文然后一路点next下来，设置下账号密码就可以了。\n  ","description":"","tags":["ubuntu","VirtualBox"],"title":"VirtualBox 安装 Ubuntu开发环境","uri":"/posts/linux/"},{"categories":["数据结构与算法"],"content":"ST表 引言 给出一个长度为$n$的数组，再给出$m$个询问,每次询问任意区间$[l,r]$的最小值。\n这是一个常见的RMQ问题。显然当n,m为$10^5$量级时，暴力$n^2$算法行不通。\n当然这种可以区间合并的问题我们都可以用线段树来解决（$nlogn$),而且线段树应用范围还会比ST倍增算法更广。\n但是由于当m很大的时候线段树可能会被卡常（不会真的有出题人这么丧心病狂吧），同时引入LCA的倍增求法，还是来写下ST倍增算法吧。\n正文 首先，要求一个任意区间$[l,r]$，如果我们知道两个区间$[l,k]$和$[k,r]$,同时保证这两个区间能完全覆盖$[l,r]$，那么这两个区间的min再min一下就可以了。\n我们先预处理一下，用$dp[i][j]$表示区间起始点为$i$，长度为$2^j$的区间的最小值（倍增算法的核心）\n显然$dp[i][0]$应初始化为$a[i]$\n同时可以得到dp的递推公式 $dp[i][j]=min(dp[i][j-1],dp[i+(1\u003c\u003c(j-1))][j-1])$\n$dp[i][j-1]$表示前半部分，$dp[i+(1\u003c\u003c(j-1))][j-1])$表示后半部分。\n那么怎么查询任意区间呢？我们不妨令$k=log2(r-l+1)$，显然$\\frac{r-l+1}{2}\u003c=2^k\u003cr-l+1$\n这样就回到一开始的问题可以实现$O1$查询了。\n同理RMQ还可以用来查询区间gcd等区间合并会有重复但不影响结果的东西。\n贴下模板\n1 2 3 4 5 6 7 8 9 10 11  void stinit(int n){ for(int i=1;i\u003c=n;i++) dp[i][0]=a[i]; for(int j=1;(1\u003c\u003cj)\u003c=n;j++) for(int i=1;i+(1\u003c\u003cj)-1\u003c=n;i++) dp[i][j]=max(dp[i][j-1],dp[i+(1\u003c\u003c(j-1))][j-1]); } int query(int l,int r){ int k=log2(r-l+1); int res=max(dp[l][k],dp[r-(1\u003c\u003ck)+1][k]); return res; }   LCA 给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。\n如果询问只有一次，很简单，我们只需要顺着两个点往上走，求出两条链，然后最早在两条链中均有出现的点就是最近公共祖先。比如说3，5的最近公共祖先。两条链为3-\u003e1-\u003e4, 5-\u003e1-\u003e4，所以3，5的lca为1。\n但当询问次数一大，这种暴力方法显然不可取了。\n所以我们可以考虑用上面的ST表来加速这种暴力方法。\n比如说要求节点u，v的最近公共祖先\n我们先dfs一遍求出u，v到根的距离$dis$，接下来把节点较深的那个移至和另一个节点dis相同的距离。\n一步一步移太慢了，由于任意一个数都可以由二进制来表示，我们每次走$2^i$的步，$i$同时减小就可以。（$i$的初值可以设为$log2(dis[u])$或一个比较大的常数，比如20。\n注意移到相同层次时会有一个特殊情况，即v是u的祖先，这种情况直接返回v即可。\n一般情况下，移动同一层次后，若u往上走$2^i$步与v往上走$2^i$步不为同一个点，则将它们同时往上走$2^i$步,这样移动后就能保证father[u]=father[v]（这里相当于用二进制来表示dis[u]到dis[lca(u,v)]的距离）\n那么怎么用代码来实现移动呢？\n可以发现我们移动的步数都是$2^i$步，因此可以用st表来预处理出$p[i][j]$表示编号为$i$的节点向上$2^j$单位的祖先节点。\n贴个模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  #include\u003cbits/stdc++.h\u003e#define ll long long #define debug(x) cout\u003c\u003c#x\u003c\u003c'='\u003c\u003cx\u003c\u003cendl #define set0(x) memset(x,0,sizeof(x)) using namespace std; const int inf=0x3f3f3f3f; const int maxn=5e5+10; vector\u003cint\u003eg[maxn]; int dis[maxn],p[maxn][25],par[maxn]; void dfs(int u,int fa){ par[u]=fa; for(int i=0;i\u003cg[u].size();i++) { if(g[u][i]==fa) continue; dis[g[u][i]]=dis[u]+1; dfs(g[u][i],u); } } void lca(int n,int s){ memset(dis,0,sizeof(dis)); dis[s]=1;dfs(s,0); memset(p,-1,sizeof(p)); for(int i=1;i\u003c=n;i++) p[i][0]=par[i]; for(int j=1;(1\u003c\u003cj)\u003c=n;j++) for(int i=1;i\u003c=n;i++){ if(p[i][j-1]!=-1) p[i][j]=p[p[i][j-1]][j-1]; } } int query(int u,int v){ if(dis[u]\u003cdis[v]) swap(u,v);//深度深的设为u  //int log=log2(dis[u]);  for(int i=20;i\u003e=0;i--) if(dis[p[u][i]]\u003e=dis[v]) u=p[u][i];//移至同一层  if(u==v) return u; for(int i=20;i\u003e=0;i--){ if(p[u][i]!=-1\u0026\u0026p[u][i]!=p[v][i]){ u=p[u][i];v=p[v][i]; } } return par[u]; } int main() { int n,m,s; cin\u003e\u003en\u003e\u003em\u003e\u003es; for(int i=1;i\u003cn;i++){ int u,v; cin\u003e\u003eu\u003e\u003ev; g[u].push_back(v); g[v].push_back(u); } lca(n,s); while(m--) { int u,v; cin\u003e\u003eu\u003e\u003ev; cout\u003c\u003cquery(u,v)\u003c\u003cendl; } return 0; }   ","description":"","tags":["ST","LCA"],"title":"ST\u0026LCA","uri":"/posts/st/"},{"categories":["数据结构与算法"],"content":"反素数 对于任何正整数$x$，其约数的个数记作$g(x)$。例如$g(1)=1、g(6)=4$。\n如果某个正整数x满足：$g(x)\u003eg(i) (0\u003ci\u003cx)$，则称$x$为反素数。例如，整数1，2，4，6等都是反质数。\n我们知道对于$x$质因数分解，使得$x=p_1^{c_1}\\times p_2^{c_2}\\times\\ p_k^{c_k}$\n则$x$的约数个数为$(c_1+1)(c_2+1)(c_k+1)$\n那么我们可以先将素数打表，dfs枚举每个素数取了几次去更新出最小值。\n当然dfs的时候通过一些剪枝大大提高效率。\n前15个素数均只取一次的乘积已经大于2^64，所以只要枚举前15个素数。\n同时每个素数最多取的次数也不会超过64次。\n贴下模板：\npos代表枚举第几个素数，value为当前的值，num为当前的约数个数，k为给出的约数个数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  int prime[] = {2,3,5,7,11,13,17,19,23,29,31,37,41,47,53}; void dfs(int pos,ll value,ll num) { if(num\u003ek||pos\u003e15) return; if(num==k) { ans=min(ans,value); return; } for(int i=1;i\u003c=63;i++) { if(value \u003e ans/prime[pos] || num*(i+1)\u003ek) break; value=value*prime[pos]; if(k%(num*(i+1))==0) //约数个数应为k的约数  dfs(pos+1,value,num*(i+1)); } } dfs(0,1,1);   ","description":"","tags":["数论"],"title":"反素数","uri":"/posts/%E5%8F%8D%E7%B4%A0%E6%95%B0/"},{"categories":["数据结构与算法"],"content":"中国剩余定理 我们先来看这样一个问题：\n求满足以下条件的整数：除以3 余2 ，除以 5余3 ，除以 7余2 。\n这是中国古代《孙子算经》中的一个问题，并给出了解法， 宋朝数学家秦九韶于 1247 年《数书九章》卷一、二《大衍类》对该问题做出了完整系统的解答。由此诞生了中国剩余定理(CRT)，并被国际公认。\n那么CRT可用于求解如下形式的一元线性同余方程组。（其中$p_1,p_2,...,p_n$两两互质）\n我们先来看下上面这个问题，求x满足\n1.$x;mod;3=2$\n2.$x;mod;5=3$\n3.$x;mod;7=2$\n先看第一个式子，我们假设存在$x_1,x_2,x_3$满足$x_1;mod;3=2,x_2;mod;5=3，x_3;mod;7=2$\n那么，我们可以构造$x=(x_1+x_2+x_3)$为原方程组的一个解，我们只需满足一下条件\n1.$x_1;mod;3=2$且$x_2,x_3$是3的倍数\n2.$x_2;mod;5=3$且$x_1,x_3$是5的倍数\n3.$x_3;mod;7=2$且$x_1,x_2$是7的倍数\n所以可得，我们要求\n1.$x_1;mod;3=2$且$x_1$是（5，7）的公倍数\n2.$x_2;mod;5=3$且$x_2$是（3，7）的公倍数\n3.$x_3;mod;7=2$且$x_3$是（3，5）的公倍数\n那么，运用逆元的思想，我们不妨构造$x_1=2\\times 5\\times 7\\times inv(5\\times 7,3)$\n这样既保证了$x_1$在是（5，7）的公倍数，同时由于逆元，在mod 3的情况下，$x_1 mod;3$的值也保证为2；\n所以我们可以将此推广\n由于$p_1,p_2,...,p_n$两两互质，所以LCM（$p_1,p_2,...,p_n$）=$p_1p_2...p_n$，记为P\n那么$x_i=a_i\\times\\frac{P}{p_i}\\times inv(\\frac{P}{p_i},p_i)$\n所以得到的 $\\sum_{i=1}^{n}x_i$ 即为我们构造出来的一个解。\n注意这样构造出来的解并不是最小的，每P个数就会有一个解。所以如果题目要我们求最小的解，我们还要做\n$x=(x;mod;p+p)mod;p$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  ll exgcd(ll a, ll b, ll \u0026x, ll \u0026y) { if (!b) { x = 1; y = 0; return a; } ll d = exgcd(b, a % b, x, y); ll t = x; x = y; y = t - (a / b) * y; return d; } ll inv(ll a,ll p) { ll x=1,y=0; exgcd(a,p,x,y); x=(x%p+p)%p; return x; } ll crt(int n) { ll ans=0,lcmp=1; for(int i=1;i\u003c=n;i++) lcmp*=p[i]; for(int i=1;i\u003c=n;i++) { ll t=lcmp/p[i]; ans=(ans+a[i]*t*inv(t,p[i]))%lcmp; } ans=(ans%lcmp+lcmp)%lcmp; return ans; }   拓展中国剩余定理（exrct） 那么，如果题目中$p_1,p_2,...,p_n$不互质，就不能保证一定存在$inv(\\frac{P}{p_i},p_i)$,所以不能再像上面一样构造求解了。\n所以就有了拓展中国剩余定理。（其实感觉两者没什么关系，构造的方式几乎完全不一样）\n我们先来看只有两个方程的情况。\n$x\\equiv a_1(mod;m_1)$\n$x\\equiv a_2(mod;m_2)$\n不妨设\n$x=x_1m_1+a_1$\n$x=x_2m_2+a_2$\n所以\n$x_1m_1+a_1=x_2m_2+a_2$\n由于$x_1;x_2$的取值可以为负无穷到正无穷，所以它们前面的符号即使写反也没关系。\n$m_1x_1+m_2x_2=a_2-a_1$\n那么这个不定方程可以就可以通过exgcd来求解。\n同时，这个求解的过程相当于把这两个方程合并成了一个方程。\n$x\\equiv c(mod;lcm(m_1,m_2)) $($c$即为这两个方程的最小正整数解)\n因此，有多个方程的话，我们只需两两合并下去，就能得到最后的解了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  ll m[maxn],a[maxn]; ll exgcd(ll a, ll b, ll \u0026x, ll \u0026y) { if (!b) { x = 1; y = 0; return a; } ll d = exgcd(b, a % b, x, y); ll t = x; x = y; y = t - (a / b) * y; return d; } ll excrt(int n) { ll M=m[1],A=a[1],x,y,t; for(int i=2;i\u003c=n;i++) { ll d=exgcd(M,m[i],x,y); if((a[i]-A)%d) return -1; x*=(a[i]-A)/d,t=m[i]/d,x=(x%t+t)%t;//解不定方程  A=M*x+A,M=M/d*m[i],A%=M; } A=(A%M+M)%M; return A; } int main() { int n; cin\u003e\u003en; for(int i=1;i\u003c=n;i++) cin\u003e\u003em[i]\u003e\u003ea[i]; cout\u003c\u003cexcrt(n)\u003c\u003cendl; return 0; }   ","description":"","tags":["CRT","EXCRT"],"title":"中国剩余定理","uri":"/posts/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"},{"categories":["数据结构与算法"],"content":"拓展欧几里得 我们先回忆一下朴素的欧几里得算法（辗转相除法）\n$gcd(a,b)=gcd(b,a%b)$\n1  ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}   而拓展欧几里得（exgcd）常用来求$ax+by=gcd(a,b)$的一组解。\nax+by=gcd（a,b) 设$x_1,y_1$满足原方程$ax_1+by_1=gcd(a,b)$\n根据欧几里得算法不妨构造这样一个方程：\n$x_2,y_2$满足$bx_2+(a;mod;b)y_2=gcd(b,a;mod;b)$\n所以可得 $ax_1+by_1=bx_2+(a;mod;b)y_2$\n由于$a;mod;b=a-(\\lfloor\\frac{a}{b}\\rfloor\\times b)$\n代入化简，得$ax_1+by_1=ay_2+b(x_2-\\lfloor\\frac{a}{b}\\rfloor y_2)$\n所以可得$x_1=y_2,y_1=x_2-\\lfloor\\frac{a}{b}\\rfloor y_2$\n我们知道欧几里得算法不停辗转相除下去，最终会得到a=gcd（a，b），b=0。\n因此我们可以根据这个性质不停的构造如上的方程，最后会得到\n$gcd(a,b)x+0\\times y=gcd(gcd(a,b),0)$\n显然此时x=1，y=0可作为方程的一组解，那么只需将这组解往回迭代上去就可以求得原方程的解了。\n1 2 3 4 5 6 7 8 9 10 11 12 13  ll exgcd(ll a, ll b, ll \u0026x, ll \u0026y) { if (!b) { x = 1; y = 0; return a; } ll d = exgcd(b, a % b, x, y); ll t = x; x = y; y = t - (a / b) * y; return d; } //exgcd返回的值为gcd（a，b）   ax+by=c 通过上面的方程求解我们不难得到对一个更加普通的不定方程$ax+by=c$的一组解。\n设$x_0,y_0$满足$ax_0+by_0=gcd(a,b)$\n将$ax_0+by_0=gcd(a,b)$两边同除gcd（a，b）再同乘c\n可得$a\\frac{cx_0}{gcd(a,b)}+b\\frac{cy_0}{gcd(a,b)}=c$\n所以，$x=\\frac{c}{gcd(a,b)}x_0,y=\\frac{c}{gcd(a,b)}y_0$\n同时，我们发现$ax+by=c$存在整数解的充要条件为$c%gcd（a,b）=0$；\n那么，如果题目要求我们求出x的最小可行解呢？\n可令$t=b/gcd(a,b)$，最小的$x=(x;mod;t+t)mod;t$\n我们为了让x最小，那么y要尽可能的大，我们可以将x尽可能分成每份为t，因为$t\\times a$可以被b整除，所以这些从x里分出来的可给y，那么剩下的x就最小了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  ll exgcd(ll a, ll b, ll \u0026x, ll \u0026y) { if (!b) { x = 1; y = 0; return a; } ll d = exgcd(b, a % b, x, y); ll t = x; x = y; y = t - (a / b) * y; return d; } //ax+by=c,ax%b=c%b; ll lieu(ll a,ll b,ll c,ll \u0026x,ll \u0026y) { ll d=exgcd(a,b,x,y); if(c%d!=0)return 0; ll k=c/d; x*=k; y*=k; ll t=b/d; x=(x%t+t)%t; y=(c-a*x)/b; return x; }   线性同余方程 $ax\\equiv c(mod;b)$\n将上面的$ax+by=c$两边同时mod b，我们发现它就转化为$ax\\equiv c(mod;b)$这个式子。\n也就是说其实$ax+by=c$与 $ax\\equiv c(mod;b)$是等价的，那么我们其实已经知道如何求得线性同余方程的解了。\n同时我们也知道线性同余方程有解的充要条件为$c%gcd（a,b）=0$\n","description":"","tags":["exgcd"],"title":"拓展欧几里得","uri":"/posts/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"},{"categories":["数据结构与算法"],"content":"乘法逆元 首先来普及一下同余定理：\n $(a+b)%p=(a%p+b%p)%p$ $(a-b)%p=((a%p-b%p)+p)%p$ (防止出现负数的情况) $(a\\times b)%p=(a%p\\times b%p)%p$ $(b\\div a)%p=(b%p\\div a%p)%p$ (并不成立)  很显然第4个公式是不对的，那么当我们碰到要边除边取模的情况，该怎么处理呢？答案是使用乘法逆元。\n就笔者个人理解，我们知道除一个数相当于乘这个数的倒数，那么在模运算的前提下，对于$(b\\div a)%p$这个式子，我们也可以按照这个思想找到一个数x来代替b，使得$(b\\times x)%p=(b\\div a)%p$,这样的数x，我们就称之为对于%p时a的逆元，记为x=inv（a，p）\nTips：x的值由a和p共同决定，这点和倒数有点不太一样，即对于一个固定的a，p不同时x的值也不同。\n那么，inv（a，p）要怎么去求呢？一般是通过费马小定理或者拓展欧几里德去求。\n逆元定义 我们将$(b\\times x)%p=(b\\div a)%p$两边同乘一个a，得到一个线性同余方程$ax\\equiv 1(mod;p)$，x就记为a mod p的逆元。(a和p互质的情况下才存在逆元)\n费马小定理求法（只适用于p为质数） 直接给出结论，$inv(a,p)=a^{p-2}$\n下面是证明，不敢兴趣的可以直接跳过。\n费马小定理：\n若p为质数，a为正整数，且a，p互质，则$a^{p-1}\\equiv 1(mod;p)$\n因为$ax\\equiv 1(mod;p) $\n所以$ax\\equiv a^{p-1}(mod;p)$\n所以$x=a^{p-2}(mod;p)$\n用快速幂求解即可。\n1 2 3 4 5 6 7 8 9 10 11 12  ll quickpow(ll x,ll n,ll mod) { ll res=1; while(n) { if(n\u00261) res=res*x%mod; x=x*x%mod; n\u003e\u003e=1; } return res; } x=quickpow(a,mod-2,mod);   拓展欧几里得求法 这里涉及到用exgcd解线性同余方程组的方法。\n鉴于这是一块新的知识点，所以从头开始介绍了exgcd。\n请移步：拓展欧几里得\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  //ax%b=1%b，ax+by=1; ll exgcd(ll a, ll b, ll \u0026x, ll \u0026y) { if (!b) { x = 1; y = 0; return a; } ll d = exgcd(b, a % b, x, y); ll t = x; x = y; y = t - (a / b) * y; return d; } ll inv(ll a,ll p) { ll x=1,y=0; exgcd(a,p,x,y); x=(x%p+p)%p; return x; }   ","description":"","tags":["逆元","数论"],"title":"乘法逆元","uri":"/posts/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"},{"categories":["数据结构与算法"],"content":"Prefix-Suffix Palindrome 题目大意：给你一个字符串，你需要找到一个最长的只能由原串的前缀和后缀构成且是回文的字符串。\n原题链接\ninput\n5\ra\rabcdfdcecba\rabbaxyzyx\rcodeforces\racbba\routput\na\rabcdfdcba\rxyzyx\rc\rabba\r解题思路：\n首先，要满足只能由前缀和后缀构成且是回文，那我们考虑先从首和尾开始取相同的字符（这样一定满足回文）直到碰到不相同的字符，我们记首开头的为s1,尾结束的为s2。\n然后，为了要保证最长，我们在剩下的串中从首或者尾开始取出最长的回文串mids。（注意，一定要从头和尾开始，不然满足不了只要前缀和后缀构成）。\n那么，我们的答案就是s1+mids+s2，显然满足题目中的条件。\n但是，这题的mids怎么去求呢，也就是说一个串的最长前缀回文串怎么去求。暴力的方法是n^2，但是这题的n是10^6，显然不可行。有没有高效的求法呢，主要有两种，一种是 Manache 算法（占个坑，以后有机会补）。还有一种是kmp算法（也是今天刚学，呜呜呜）。这里来讲一下如何用kmp求最长前缀回文。\n没学过kmp的可以看下笔者的这篇笔记。\n我们知道，kmp算法中有一个求nex[j]数组的重要步骤。（nex[j]表示从0-j前缀中（不包括j）的前缀和后缀相等的最长长度）。那么，我们只需将mids翻转得到的rev和原来的mids串拼接起来，得到s。这样mids最长的前缀回文串就出现在s的后缀，这个时候如果满足前缀和后缀相等，那么就等价于满足了回文这个条件，也就是说我们只要求nex[slen]就行了。\n但是还有个细节要注意下，我们看下如果mids=“uwwuw”，那么s=“uwwuwwuwwu” 对于这样的s，我们所求出来的nex[slen]=7，但实际上满足题意的解应该为4，原因是我们的最长回文前缀原则上应小于mids的长度，但转化为求nex的时候这个限制没了。\n所以我们可以在拼接起来的时候中间加上一个“￥”，那么s=“uwwuw￥wuwwu”，这样在求nex的时候，对于￥后面的位，我们只会拿￥后的后缀去与前面匹配，就不会越过界了。\nAC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  #include\u003cbits/stdc++.h\u003e#define ll long long #define debug(x) cout\u003c\u003c#x\u003c\u003c'='\u003c\u003cx\u003c\u003cendl #define set0(x) memset(x,0,sizeof(x)) using namespace std; const int inf=0x3f3f3f3f; const int maxn=2e6+10; int nex[maxn]; int getnex(string s) { int len=s.size(); for(int i=0;i\u003c=len;i++) nex[i]=0; nex[0]=-1; int j=0,k=-1; while(j\u003clen) { if(k==-1||s[j]==s[k]) { k++; j++; nex[j]=k; } else k=nex[k]; } return nex[len];//nex表示的是不含这位的，所以我们要求nex[len] } int main() { int t; cin\u003e\u003et; while(t--) { string s; cin\u003e\u003es; int len=s.size(); int st=0,ed=len-1; while(st\u003ced) if(s[st]==s[ed]) st++,ed--;else break;//求出s1和s2  string mids=s.substr(st,ed-st+1); string rev=mids;reverse(rev.begin(),rev.end()); string qz,hz; qz=mids+\"￥\"+rev;//避免匹配的前缀后缀越界  int tt=getnex(qz); hz=rev+\"￥\"+mids; int mm=getnex(hz); if(tt\u003e=mm) mids=mids.substr(0,tt); else mids=rev.substr(0,mm); for(int i=0;i\u003cst;i++) cout\u003c\u003cs[i]; cout\u003c\u003cmids; for(int i=st-1;i\u003e=0;i--) cout\u003c\u003cs[i]; cout\u003c\u003cendl; } return 0; }   ","description":"","tags":["KMP"],"title":"CF1326 D2","uri":"/posts/d2/"},{"categories":["数据结构与算法"],"content":"写篇博客纪念一下自闭的一场。（我好弱啊，呜呜呜）\n下面题解的思路参考了大佬的博客，贴一下原博客链接，欢迎来%%%\n%%%%\n数对统计 题目大意：\n给定一个序列，求多少对（i，j）满足 $a_i - a_j \u003e a_i + a_j$ (i,j不能相等)\n解题思路：\n一开始化简后以为看错题了，发现其实就字面意思。化简后得到aj\u003c0,那么对数就是负数的个数*（n-1）\nAC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  #include\u003cbits/stdc++.h\u003e#define ll long long #define debug(x) cout\u003c\u003c#x\u003c\u003c'='\u003c\u003cx\u003c\u003cendl #define set0(x) memset(x,0,sizeof(x)) using namespace std; const int inf=0x3f3f3f3f; const int maxn=2e6+10; int main() { int n; ll ans=0; cin\u003e\u003en; for(int i=0;i\u003cn;i++) { ll x; cin\u003e\u003ex; if(x\u003c0) ans++; } cout\u003c\u003cans*(n-1)\u003c\u003cendl; //system(\"pause\");  return 0; }   混合饮料 题目大意：\n小明喝一杯刚开始由茶和牛奶等比混合的饮料。给定一个“HM”串，H代表喝掉半杯饮料，再倒入半杯茶。M代表喝掉半杯饮料，再倒入半杯牛奶。每次都混合均匀。按HM串喝，问最后喝掉的牛奶多还是茶多。\n解题思路：\n按题意模拟即可。double精度够用。（至少在这题的数据是这样的。）\nAC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  #include\u003cbits/stdc++.h\u003e#define ll long long #define debug(x) cout\u003c\u003c#x\u003c\u003c'='\u003c\u003cx\u003c\u003cendl #define set0(x) memset(x,0,sizeof(x)) using namespace std; const int inf=0x3f3f3f3f; const int maxn=2e6+10; int main() { int t; cin\u003e\u003et; while(t--) { int n; cin\u003e\u003en; string s; cin\u003e\u003es; double nx=0.5,ny=0.5,x=0,y=0; for(int i=0;i\u003cn;i++) { if(s[i]=='H') { x+=nx/2; y+=ny/2; nx/=2,ny/=2; nx+=0.5; } if(s[i]=='M') { x+=nx/2; y+=ny/2; nx/=2,ny/=2; ny+=0.5; } } if(x\u003ey) cout\u003c\u003c\"H\"\u003c\u003cendl; else if(x==y) cout\u003c\u003c\"HM\"\u003c\u003cendl; else cout\u003c\u003c\"M\"\u003c\u003cendl; } //system(\"pause\");  return 0; }   黑暗长廊 题目大意：\n小明在一条只有第一盏灯亮的长廊上，当他走到某个位置时，可以打开或关闭这个位置上的灯，每盏灯有可以照亮的范围，小明只能在灯光下行动。求当小明走到第n盏灯，且除了第n盏灯亮，其他灯全灭 所需要的最短路径。如果不能到达，输出 “-1”\n解题思路：\n不难发现，不管我们选择哪几个灯路过最终到达n灯处，所行的距离始终是3*(xn-x1)，也就是来回三趟。\n所以我们只要判断能否从起点到达终点，并能否从终点返回起点，如果有一侧不行，就输出-1\n判断能否到达，从起点开始，到一个点，每次更新所能到达的最大范围。如果中途出现无法到达下一个点的情况，就表示不行。\nAC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  #include\u003cbits/stdc++.h\u003e#define ll long long #define debug(x) cout\u003c\u003c#x\u003c\u003c'='\u003c\u003cx\u003c\u003cendl #define set0(x) memset(x,0,sizeof(x)) using namespace std; const int inf=0x3f3f3f3f; const int maxn=2e6+10; ll x[maxn],r[maxn]; template\u003cclass T\u003einline void read(T \u0026x) { x=0; int ch=getchar(),f=0; while(ch\u003c'0'||ch\u003e'9'){if (ch=='-') f=1;ch=getchar();} while (ch\u003e='0'\u0026\u0026ch\u003c='9'){x=(x\u003c\u003c1)+(x\u003c\u003c3)+(ch^48);ch=getchar();} if(f)x=-x; } int main() { int t; cin\u003e\u003et; while(t--) { int n; cin\u003e\u003en; for(int i=1;i\u003c=n;i++) read(x[i]),read(r[i]); ll flag=1,mx=x[1]+r[1]; ll ans=3*(x[n]-x[1]); for(int i=1;i\u003c=n-1;i++) { if(x[i+1]\u003c=mx) mx=max(mx,x[i+1]+r[i+1]); else { flag=0; break; } } mx=x[n]-r[n]; for(int i=n;i\u003e=2;i--) { if(x[i-1]\u003e=mx) mx=min(mx,x[i-1]-r[i-1]); else { flag=0; break; } } if(flag) cout\u003c\u003cans\u003c\u003cendl; else puts(\"-1\"); } //system(\"pause\");  return 0; }   咖啡馆 题目大意：\n小明要建咖啡馆。已知小明的村庄有n位住户及他们的住址。咖啡馆最多能容纳k位顾客。\n问当k分别取1，2，3.......k时，小明建的咖啡馆到这k位住户最短的哈密顿距离之和。\n解题思路：\n首先回想一个经典问题。\n已知n个点，在平面上任意取一点使其到这n个点的哈密顿距离之和最短。\n我们首先考虑这n个点在同一条直线上的情况，那么显然当n为奇数的时候，我们肯定取中位点（最中间的那个点）来保证距离之和最短。当n为偶数的情况时，我们取的就是最中间的两个点之间（包括这两个点）的任意一点。\n那么从一维拓展到二维，我们只要从所有的x中取一个中位数，所有的y中取一个中位数。这个（X中，Y中）就是答案。值得注意的是，（X中，Y中）这个坐标不一定在这几个n点上，但是我们将所有的x和所有的y两两搭配一定能得到这个点。这也是解这道题的关键。\n对于k位顾客，我们不管从这n个住户中挑哪k位，得到的答案点一定是在n个x和y的两两搭配中。\n所以我们可以枚举x和y的两两搭配，然后求出n个点到这个点的距离并排序，选取最前面的k位作为顾客就好了。\nAC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  #include\u003cbits/stdc++.h\u003e#define ll long long #define debug(x) cout\u003c\u003c#x\u003c\u003c'='\u003c\u003cx\u003c\u003cendl #define set0(x) memset(x,0,sizeof(x)) using namespace std; const int inf=0x3f3f3f3f; const int maxn=2e2+10; #define int long long int x[maxn],y[maxn],a[maxn],ans[maxn],sum[maxn]; signed main() { int n,k; cin\u003e\u003en\u003e\u003ek; for(int i=1;i\u003c=n;i++) cin\u003e\u003ex[i]\u003e\u003ey[i]; for(int i=0;i\u003c=k;i++) ans[i]=999999999999;//（要足够大，不然过不了）  for(int i=1;i\u003c=n;i++) for(int j=1;j\u003c=n;j++) { int x0=x[i],y0=y[j];//枚举x和y的两两搭配，答案点必在其中  set0(a),set0(sum); for(int ii=1;ii\u003c=n;ii++) a[ii]=abs(x0-x[ii])+abs(y0-y[ii]);//到n个点的距离  sort(a+1,a+n+1); for(int ii=1;ii\u003c=k;ii++) sum[ii]=sum[ii-1]+a[ii];//前缀和处理  for(int kk=1;kk\u003c=k;kk++) ans[kk]=min(ans[kk],sum[kk]); } for(int i=1;i\u003c=k;i++) cout\u003c\u003cans[i]\u003c\u003cendl; //system(\"pause\");  return 0; }   偶数序列 题目大意：\n给定一个整数序列$a_1,a_2,a_3...a_n$和参数k。\n定义一个序列是k偶数序列，当且仅当对于每个$i(1≤i≤n−k+1)$, $a_i +a_{i+1}...+a_{i+k-1}$都是偶数。\n请计算最少修改其中多少个数字可以使得这个序列变成k偶数序列。\n解题思路：\n要是所有k序列都是偶数，必然会满足$a_1$和$a_{1+k}$, $a_2$和$a_{2+k}$......的奇偶性相同，因为第1个k序列和第2个k序列相差的只有$a_1$和$a_{1+k}$\n所以，我们不妨把所有a按模k同余分成k组，比如n=8，k=3时，{$a_1$，$a_4$，$a_7$}为一组，{$a_2$，$a_5$，$a_8$}为一组，\n{$a_3$，$a_6$}为一组。这样由上面的结论得同一组的奇偶性一定都一样。\n所以，我们只要求得每组数全变成奇数或偶数的最小代价，然后对奇数组的个数计个数cnt，如果cnt位偶数的话，那么就已经满足所有k序列都为偶数了。如果cnt为奇数的话，我们要再让一组奇偶反转，找反转最小代价的一组，加到ans里即可。\nAC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  #include\u003cbits/stdc++.h\u003e#define ll long long #define debug(x) cout\u003c\u003c#x\u003c\u003c'='\u003c\u003cx\u003c\u003cendl #define set0(x) memset(x,0,sizeof(x)) using namespace std; const int inf=0x3f3f3f3f; const int maxn=2e6+10; int a[maxn]; struct node { int x,y;//x 奇数 y偶数 }t[maxn]; int main() { int n,k; cin\u003e\u003en\u003e\u003ek; for(int i=1;i\u003c=n;i++) { cin\u003e\u003ea[i]; a[i]=a[i]%2; if(a[i]==1)t[i%k].x++; else t[i%k].y++; } ll ans=0,cnt=0; int mx,minn=inf; for(int i=0;i\u003ck;i++) { if(t[i].x\u003et[i].y) ans+=t[i].y,cnt++; else ans+=t[i].x; if(abs(t[i].x-t[i].y)\u003cminn) mx=i,minn=abs(t[i].x-t[i].y);//反转代价最小的  } if(cnt%2==1) { ans=ans+abs(t[mx].x-t[mx].y); } cout\u003c\u003cans\u003c\u003cendl; return 0; }   ","description":"","tags":null,"title":"杭电ACM集训队-2020状态监测练习赛（2）","uri":"/posts/%E6%9D%AD%E7%94%B5acm%E9%9B%86%E8%AE%AD%E9%98%9F-2020%E7%8A%B6%E6%80%81%E7%9B%91%E6%B5%8B%E7%BB%83%E4%B9%A0%E8%B5%9B2/"},{"categories":["数据结构与算法"],"content":"Skyscrapers 原题链接\n大致题意：\n有若干个高楼，每个高楼都有ai的高度限制，同时要满足没有一幢高楼比它相邻的两幢高楼都低，即没有i既满足 j\u003ci\u003ck又满足 aj\u003e ai\u003cak\nExamples\ninput\n5\r1 2 3 2 1\routput\n1 2 3 2 1 input\n3\r10 6 8\routput\n10 6 6 其实这题的结果最后一定是一个单峰的图像（左边单调递增，右边单调递减）为什么呢？\n因为如果有两个峰，那么必然会产生一个谷底，那么就不满足题意。\n也就是说我们只要找到那个单峰，然后贪心的模拟就好了。\n最简单的方法来寻找结果最大的单峰就是直接枚举，也是这题easy版本的做法，n为1000。\n但是这题的n有5e6，显然不能枚举了。\n由于其左右两边分别具有单调性，我们不如去维护这两个数组\ns1[i] 表示从1-i满足单调递增的前提下最大的sum\ns2 [i] 表示从i-n满足单调递减的前提下最大的sum\n如果 a[i]\u003e=a[i-1] 那么s1[i]=s1[i-1]+a[i];\na[i]\u003ca[i-1] 那么我们需要从a[i-1]开始倒着往前找到第一个\u003c=a[i]的数，然后把原本\u003ea[i]的数都变成a[i]来维护\n刚开始我是按照这个思路来维护，发现还是会tle，然后参考了一下题解，把单调栈里存的a[i]改成i下标就好了，这样就不用一个一个去push和pop了。\n注意：使用stack.top( )之前一定要判断下是否为空！！！\nAC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  #include\u003cbits/stdc++.h\u003e#define debug(x) cout\u003c\u003c#x\u003c\u003c'='\u003c\u003cx\u003c\u003cendl #define set0(x) memset(x,0,sizeof(x)) #define ll long long #define inf 0x3f3f3f3f #define ls id\u003c\u003c1 #define rs id\u003c\u003c1|1 using namespace std; const int maxn=5e5+10; ll a[maxn],s1[maxn],s2[maxn]; stack\u003cint\u003es; int main() { //freopen(\"in.txt\",\"r\",stdin);  int n; cin\u003e\u003en; for(int i=1;i\u003c=n;i++) cin\u003e\u003ea[i]; for(int i=1;i\u003c=n;i++) {\ts1[i]=s1[i-1]; if(a[i]\u003e=a[i-1]) s.push(i),s1[i]+=a[i]; else { while(!s.empty()\u0026\u0026a[s.top()]\u003ea[i]) s.pop(); if(!s.empty()) s1[i]=s1[s.top()]+(i-s.top())*a[i]; else s1[i]=a[i]*i; s.push(i);\t} } while(!s.empty()) s.pop(); for(int i=n;i\u003e=1;i--) {\ts2[i]=s2[i+1]; if(a[i]\u003e=a[i+1]) s.push(i),s2[i]+=a[i]; else { while(!s.empty()\u0026\u0026a[s.top()]\u003ea[i]) s.pop(); if(!s.empty()) s2[i]=s2[s.top()]+(s.top()-i)*a[i]; else s2[i]=a[i]*(n-i+1); s.push(i);\t} } ll maxx=0,maxi; for(int i=1;i\u003c=n;i++) { if(s1[i]+s2[i]-a[i]\u003emaxx) { maxi=i; maxx=s1[i]+s2[i]-a[i]; } } //\tfor(int i=1;i\u003c=n;i++) //\tdebug(s1[i]),debug(s2[i]); //\tdebug(maxi); \tfor(int i=maxi-1;i\u003e=1;i--) a[i]=min(a[i],a[i+1]); for(int i=maxi+1;i\u003c=n;i++) a[i]=min(a[i],a[i-1]); cout\u003c\u003ca[1]; for(int i=2;i\u003c=n;i++) cout\u003c\u003c\" \"\u003c\u003ca[i]; }   ","description":"","tags":["单调栈"],"title":"CF1313 C2","uri":"/posts/c2/"},{"categories":["数据结构与算法"],"content":"树状数组 今天听老刘讲了下树状数组，再结合自己的理解。补一篇学习笔记。\n树状数组的用处：\n1.单点修改+区间查询（本质）\n2.区间修改+单点查询\n3.区间修改+区间查询\n当我们需要频繁的修改查询时，借用树状数组可以大大降低复杂度。（o（logn））\n而且树状数组较线段树的好处就是：代码简洁。（能让你深切感受到二进制之美）\n下面就来介绍一下如何构造使用树状数组。\n预备知识（lowbit） 给你一个数，其转化为二进制从右往左到第1个1的值就是这个数的lowbit值。\neg：12（1100）的lowbit值即为4（100）\n那么，lowbit（x）要怎么去计算呢？\n首先我们把x取反+1，这样得到的（~x+1）与之前的x相比只有第一个1（从右往左）的后面的数相同了。\n所以lowbit（x）=x\u0026（~x+1）\n由于计算机存储的采用是补码，所以~x+1=-x，那么lowbit（x）=x\u0026-x\n单点修改+区间查询 给出一个长度为n的数组，完成以下操作：\n1.将第x个数加上k\n2.输出区间[l,r]内每个数的和\n如上图所示，原数组设为a，树状数组设为t。\nt[1] (0001)=a[1] (0001);\nt[2] (0010)=a[1] (0001)+a[2] (0010);\nt[3] (0011)=a[3] (0011);\nt[4] (0100)=a[1] (0001)+a[2] (0010)+a[3] (0011)+a[4] (0100);\n以此类推。\n以这样的方式来存储数组的数据结构其实就是树状数组了。\n可以发现，t[x]管理的a[x]的数量取决于lowbit（x）\n而现在我们要求sum（4），其实就是t[4]的值。\nsum（6）（0110）=t[6]（0110）+t[4] （0010）\nsum （7）（0111）= t[7] (0111) + t[6]（0110）+t[4] （0010）\n又可以发现，我们要求sum(x)，只要从x开始不断减去lowbit(x)，就能还原整个管理区域。这样就保证了\nsum（x）的复杂度最多是logx。也是为什么使用树状数组的原因。\n那么当我们要进行单点更新时，不光要将t[x]+k，还要将管理x的t都加上k，也就是sum的逆向，不断加上lowbit（x)就行了。\n贴下板子（非常的简洁哟）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  const int maxn=2e6+10; //[1,n] int bit[maxn+1],n; int sum(int i) { int s=0; while(i\u003e0) { s+=bit[i]; i-=i\u0026-i; } return s; } void add(int i,int x) { while(i\u003c=n) { bit[i]+=x; i+=i\u0026-i; } }   tip：树状数组下标不能从0开始，会陷入死循环）\n区间修改+单点查询 在这里要引入差分数组d。（即a[]每个元素的增量）\neg：a[1]=1,a[2]=2,a[3]=0\nd[1]=a[1]=1, d[2]=a[2]-a[1]=1 ,d[3]=a[3]-a[2]=-2;\n那么当我们要做区间[l,r]修改+k时，由于这个区间内的差量是不发生变化的，变化的仅有边界的地方。\n因此只要对b[l]+k,b[r+1]-k就能维护区间了。\n当我们要查询单点时，可以发现a[x]= $\\sum_{i=1}^x {d[i]} \\quad$\n这样就把单点查询变回上面的区间查询了。\n因此我们只需要用树状数组来维护d这个差分数组就行了。\n代码就不贴了，因为和上面的那一份是一模一样的。只要刚开始把bit[n]初始化为差分数组即可。\n区间修改：对[l,r]的区间+k add（l,k) ,add(r+1,-k);\n单点查询（x）：a[x]=sum(x);\n区间修改+区间查询 区间修改的方式还是可以参照上面差分数组的方法。\n区间修改：对[l,r]的区间+k add（l,k) ,add(r+1,-k);\n着重来讲一下如何进行区间查询\n上面讲了单点查询的方法。\n那么不难想到**位置p的前缀和：$\\sum_{i=1}^p {a[i]} \\quad=\\sum_{i=1}^p {\\sum_{j=1}^i {d[j]} \\quad} \\quad$**\n在等式右侧，d[1]被用了p次，d[2]被用了p-1次；\n于是可知：\n$\\sum_{i=1}^p {\\sum_{j=1}^i {d[j]} \\quad} \\quad=\\sum_{i=1}^p {d[i]} \\quad*(p-i+1) =(p+1)*\\sum_{i=1}^p {d[i]} \\quad-\\sum_{i=1}^p {d[i]*i} \\quad$\n那么我们接下来只要用两个树状数组去维护d[i]和 d[i]*i 就好了。\nc1[i]=d[i];\n*c2[i]=d[i]i;\n区间查询（l，r）：sum（r）- sum（l-1）\n贴下代码吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  const int maxn=2e6+10; //[1,n] int c1[maxn+1],c2[maxn+1],n; int sum(int p) {\tint s=0,i=p; while(i\u003e0) { s+=(p+1)*c1[i]-c2[i]; i-=i\u0026-i; } return s; } void add(int p,int x) {\tint i=p; while(i\u003c=n) { c1[i]+=x,c2[i]+=x*p; i+=i\u0026-i; } }   ","description":"","tags":["BIT"],"title":"BIT(树状数组)","uri":"/posts/bit/"},{"categories":["数据结构与算法"],"content":"小字辈 原题链接\n题目大意： 给出一个家族每个家庭成员的父或母， 其中第 i 个编号对应第 i 位成员的父/母 。\n输出最小的辈分，以及顺序输出最小辈分成员的编号。\n输入样例： 9\r2 6 5 5 -1 5 6 4 7\r输出样例： 4\r1 9\r思路： 用vector存下每个人的kid。\n然后找到老祖宗，从上往下bfs即可，同时记录下每个人的辈分。\nAC代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  #include\u003cbits/stdc++.h\u003eusing namespace std; vector\u003cint\u003ekid[100000+10]; int r[100000+10];//记录每个人的辈分 int b[100000+10];//记录最小辈分成员 struct node { int id; int step; }cur,nex; void bfs(int st) { queue\u003cnode\u003eque; cur.id=st; cur.step=1; que.push(cur); while(!que.empty()) {\tcur=que.front(); que.pop(); for(int i=0;i\u003ckid[cur.id].size();i++) {\tnex.id=kid[cur.id][i]; nex.step=cur.step+1; que.push(nex); r[nex.id]=r[cur.id]+1; } } cout\u003c\u003ccur.step\u003c\u003cendl; } int main() { int n,st; cin\u003e\u003en; for(int i=1;i\u003c=n;i++) { int x; cin\u003e\u003ex; if(x==-1) { r[i]=1; st=i; } else kid[x].push_back(i); } bfs(st); int cnt=0; for(int i=1;i\u003c=n;i++){ if(r[i]==cur.step){ b[cnt++]=i; } } for(int i=0;i\u003ccnt;i++) { if(i!=cnt-1){ cout\u003c\u003cb[i]\u003c\u003c\" \"; } else{ cout\u003c\u003cb[i]\u003c\u003cendl; } } }   功夫传人 原题链接\n思路： 同上一题类似，从上往下的bfs即可。\nAC代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  #include\u003cbits/stdc++.h\u003e#define ll long long using namespace std; struct node { int id; double bs; }fs[100000+10]; vector\u003cint\u003eg[100000+10]; int b[100000+10]; map\u003cint,int\u003emp;//标记得道者 struct p { int step; int id; }cur,nex; void bfs() { cur.id=0; cur.step=0; queue\u003cp\u003eque; que.push(cur); while(!que.empty()) { cur=que.front(); que.pop(); if(mp[cur.id]) b[cur.id]=cur.step;//得道者得辈分 \t//cout\u003c\u003ccur.id\u003c\u003c\" \"\u003c\u003ccur.step\u003c\u003cendl; \tfor(int i=0;i\u003cg[cur.id].size();i++) { nex.id=g[cur.id][i]; nex.step=cur.step+1; que.push(nex); } } } int main() { int n; double z,r; cin\u003e\u003en\u003e\u003ez\u003e\u003er; int cnt=0; for(int i=0;i\u003cn;i++) {\tint x; int k; cin\u003e\u003ek; if(k==0) { fs[cnt].id=i; cin\u003e\u003efs[cnt].bs; cnt++; mp[i]=1; } else { while(k--) { cin\u003e\u003ex; g[i].push_back(x); } } } bfs(); double ans=0; r=1-r/100; for(int i=0;i\u003ccnt;i++) {\t//cout\u003c\u003cfs[i].id\u003c\u003c\" \"\u003c\u003cfs[i].bs\u003c\u003c\" \"\u003c\u003cb[fs[i].id]\u003c\u003cendl; \tans+=z*pow(r,b[fs[i].id])*fs[i].bs; } printf(\"%d\",(int)ans);   球队食物链 原题链接\n题目大意： 给出n个球队n*n的对战情况表，求“食物链”为一个1至N的排列{ T1 T2 ⋯ TN }，满足：球队T1战胜过球队T2，球队T2战胜过球队T3，⋯，球队T(N−1)战胜过球队TN，球队TN战胜过球队T1。若存在多条“食物链”，请找出字典序最小的。\n输入样例1： 5\r-LWDW\rW-LDW\rWW-LW\rDWW-W\rDDLW-\r输出样例1： 1 3 5 4 2\r输入样例2： 1 2 3 4 5 6  5 -WDDW D-DWL DD-DW DDW-D DDDD-   输出样例2： No Solution\r思路： 1.首先注意题目说的是每个球队之间会踢两场，所以题目表中L也要记录胜场。\n2.注意到如果存在这样一条食物链，那么其实是个环，也就是说1号球队一定在其中，满足字典序最小的一定也是1号球队开始的，所以只要以1号球队为起点做一次dfs即可。\n3.剪枝：把赢过1号球队的队伍先做个标记。在dfs访问一个节点时判断一下剩下来没有访问的队伍中还有没有赢过1队的，没有直接return。（这题的精髓，没有会超时）\nAC代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  #include\u003cbits/stdc++.h\u003e#define ll long long using namespace std; int vis[25],r[25],flag,cnt,n,num; int g[25][25]; void dfs(int x,int cnt) {\tif(flag) return; if(!flag) r[cnt]=x; if(cnt==n) {\tif(g[x][1]==1) { flag=1; return; } } int f = 1; for(int i = 1; i \u003c=n; i ++) { if(!vis[i] \u0026\u0026 g[i][1]) f = 0; }//精髓剪枝  if(f)return; for(int i=1;i\u003c=n;i++) {\tif(vis[i]||!g[x][i]) continue; vis[i]=1; dfs(i,cnt+1); vis[i]=0; } } int main() {\tcin\u003e\u003en; getchar(); char ch; for(int i=1;i\u003c=n;i++) { for(int j=1;j\u003c=n;j++) { scanf(\" %c\",\u0026ch); if(ch=='W') g[i][j]=1; if(ch=='L') g[j][i]=1; } } flag=0; memset(vis,0,sizeof(vis)); memset(r,0,sizeof(r)); vis[1]=1; dfs(1,1); if(flag) { for(int i=1;i\u003c=n;i++) { if(i!=n) cout\u003c\u003cr[i]\u003c\u003c\" \"; else cout\u003c\u003cr[i]; } } else puts(\"No Solution\"); }   关于堆的判断 原题链接\n题目大意： 给定一个二叉堆，判断根节点，兄弟节点，父子节点\n思路： 主要利用二叉堆父亲的编号=（儿子的编号-1）/2这个性质\n注意数据中会有负数\n输入样例： 5 4\r46 23 26 24 10\r24 is the root\r26 and 23 are siblings\r46 is the parent of 23\r23 is a child of 10\r输出样例： F\rT\rF\rT\rAC代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83  #include\u003cbits/stdc++.h\u003e#define ll long long using namespace std; const int maxn=1005; int heap[maxn],sz=0; map\u003cint,int\u003enum; void push(int x) { int i=sz++; while(i\u003e0) { int p=(i-1)/2;//父亲节点 \tif(head[p]\u003c=x) break; head[i]=head[p];//父亲下移，儿子上移 \ti=p; } heap[i]=x; } int main() { int n,m; cin\u003e\u003en\u003e\u003em; getchar(); for(int i=0;i\u003cn;i++) { int x; cin\u003e\u003ex; push(x); } getchar(); for(int i=0;i\u003cn;i++) { num[heap[i]]=i;//num存储每个数字在二叉堆里的编号 \t} while(m--) { int a=0,b=0,flag=0,f=0; int cnt=0; int ss[10]={0}; string s; getline(cin,s); s+=\" \";//防止末尾的数字读不出来 \tfor(int i=0;i\u003cs.size();i++) {\tif((s[i]-'0')\u003e=0\u0026\u0026(s[i]-'0')\u003c=9) {\ta=a*10+(s[i]-'0'); f=1; } if(s[i]=='-') flag=1;//标记负数 \tif(s[i]==' '\u0026\u0026f) {\tif(flag) ss[cnt++]=-a; else ss[cnt++]=a; flag=0; f=0; a=0; } } a=ss[0],b=ss[1]; if(s.find(\"root\")!=string::npos) { if(num[a]==0) puts(\"T\"); else puts(\"F\"); } else if(s.find(\"sibling\")!=string::npos) { if((num[b]-1)/2==(num[a]-1)/2) puts(\"T\"); else puts(\"F\"); } else if(s.find(\"parent\")!=string::npos) { if(num[a]==(num[b]-1)/2) puts(\"T\"); else puts(\"F\"); } else if(s.find(\"child\")!=string::npos) { if(num[b]==(num[a]-1)/2) puts(\"T\"); else puts(\"F\"); } } }   喊山 原题链接\n题目大意： 一个山头呼喊的声音可以被临近的山头同时听到。题目假设每个山头最多有两个能听到它的临近山头。给定任意一个发出原始信号的山头，本题请你找出这个信号最远能传达到的地方。\n若这样的山头不只一个，则输出编号最小的那个。若此山头的呼喊无法传到任何其他山头，则输出0。\n输入样例： 7 5 4\r1 2\r2 3\r3 1\r4 5\r5 6\r1 4 5 7\r输出样例： 2\r6\r4\r0\r思路： 1.注意此题虽然是求最远距离，但是首先要保证这个距离是两点之间的最短距离。例如样例中虽然可以1-\u003e2-\u003e3，但是由于1也可直接传到3，所以1到3的距离是1并不是2.\n2.对于每个询问的点标为起点，bfs，并标记这些点距离起点的距离，距离相等且序号更小时更新。\nAC代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  #include\u003cbits/stdc++.h\u003e#define ll long long using namespace std; vector\u003cint\u003eg[100000+10]; int vis[100000+10]; int dis[10000+10]; void bfs(int x) {\tint d=-1,pos; queue\u003cint\u003eque; que.push(x); dis[x]=0; while(!que.empty()) {\tx=que.front(); que.pop(); if(dis[x]\u003ed) { d=dis[x]; pos=x; } else if(dis[x]==d\u0026\u0026x\u003cpos)//距离相等更新序号小的 \tpos=x; for(int i=0;i\u003cg[x].size();i++) { if(vis[g[x][i]]) continue; que.push(g[x][i]); dis[g[x][i]]=dis[x]+1; vis[g[x][i]]=1; } } cout\u003c\u003cpos\u003c\u003cendl; } int main() { int n,m,k; cin\u003e\u003en\u003e\u003em\u003e\u003ek; while(m--) { int x,y; cin\u003e\u003ex\u003e\u003ey; g[x].push_back(y); g[y].push_back(x); } while(k--) {\tmemset(vis,0,sizeof(vis)); memset(dis,0,sizeof(dis)); int x; cin\u003e\u003ex; vis[x]=1; if(g[x].empty())//没有相邻的山头直接输出0 \t{ puts(\"0\"); continue; } bfs(x); } }   ","description":"","tags":null,"title":"天梯训练赛5 6 7","uri":"/posts/%E5%A4%A9%E6%A2%AF%E8%AE%AD%E7%BB%83%E8%B5%9B5-6-7/"},{"categories":["数据结构与算法"],"content":"家庭房产 题目链接\n题目大意：\n给出n个人的信息：编号 父 母 k 孩子1 ... 孩子k 房产套数 总面积。\n统计家庭个数，并按下列格式输出每个家庭的信息：\n家庭成员的最小编号 家庭人口数 人均房产套数 人均房产面积\r其中人均值要求保留小数点后3位。家庭信息首先按人均面积降序输出，若有并列，则按成员编号的升序输出。\n输入样例： 10\r6666 5551 5552 1 7777 1 100\r1234 5678 9012 1 0002 2 300\r8888 -1 -1 0 1 1000\r2468 0001 0004 1 2222 1 500\r7777 6666 -1 0 2 300\r3721 -1 -1 1 2333 2 150\r9012 -1 -1 3 1236 1235 1234 1 100\r1235 5678 9012 0 1 50\r2222 1236 2468 2 6661 6662 1 300\r2333 -1 3721 3 6661 6662 6663 1 100\r输出样例： 3\r8888 1 1.000 1000.000\r0001 15 0.600 100.000\r5551 4 0.750 100.000\r思路： 很显然的一道并查集。只不过在数据处理上可能会有点麻烦。\n首先定义两个结构体，node1存储题目中给出的n个人的信息，node2存储各个家庭的信息。\n考虑到要输出家庭中成员的最小编号，在使用并查集的时候不妨让小的去当根，即最小编号是每个家庭块的祖先。\n接下来就是耐心的统计了。\nAC代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137  #include\u003cbits/stdc++.h\u003eusing namespace std; #define MAX_N 10010 int par[MAX_N]; map\u003cint,int\u003emp,vis; struct node1 {\tint fa,ma,k; int kid[10]; int num;//自己的编号 \tint nhouse;//房产数 \tint phouse;//房产面积 }man[10100]; struct node2 {\tint m;//家庭中最小编号 \tint people;//家庭人数 \tdouble nhouse; double phouse;\t}family[10100]; bool cmp(node2 f1,node2 f2) { if(f1.phouse\u003ef2.phouse) return true; else if(f1.phouse==f2.phouse) return f1.m\u003cf2.m; } int find(int x) { if(par[x]==x) return x; else return(par[x]=find(par[x])); } void unite(int x,int y) { x=find(x); y=find(y); if(x==y) return; else if(x\u003ey) par[x]=y;//让编号小的去当祖先 \telse par[y]=x; } int main() {\tint n,id=0; cin\u003e\u003en; for(int i=1;i\u003c=9999;i++) par[i]=i; for(int i=1;i\u003c=n;i++) { int fa,ma,kid,k; cin\u003e\u003eman[i].num\u003e\u003eman[i].fa\u003e\u003eman[i].ma\u003e\u003eman[i].k; if(man[i].fa!=-1)unite(man[i].num,man[i].fa); if(man[i].ma!=-1)unite(man[i].num,man[i].ma); for(int j=1;j\u003c=man[i].k;j++) { cin\u003e\u003eman[i].kid[j]; if(man[i].kid[j]!=-1) unite(man[i].kid[j],man[i].num); } cin\u003e\u003eman[i].nhouse\u003e\u003eman[i].phouse; } for(int i=1;i\u003c=n;i++) {\tint minn=find(man[i].num);// \tint t=mp[minn]; if(t==0) //防止同一个家庭重复统计 \t{ mp[minn]=++id;//给每个家庭编号 \tfamily[id].m=minn; if(!vis[man[i].num]) { family[id].people++; vis[man[i].num]=1; } if(man[i].fa!=-1\u0026\u0026vis[man[i].fa]==0) { family[id].people++; vis[man[i].fa]=1; } if(man[i].ma!=-1\u0026\u0026vis[man[i].ma]==0) { family[id].people++; vis[man[i].ma]=1; } for(int j=1;j\u003c=man[i].k;j++) { if(man[i].kid[j]!=-1\u0026\u0026vis[man[i].kid[j]]==0) { family[id].people++; vis[man[i].kid[j]]=1; } } family[id].nhouse+=man[i].nhouse; family[id].phouse+=man[i].phouse; } else {\tif(!vis[man[i].num]) { family[t].people++; vis[man[i].num]=1; } if(man[i].fa!=-1\u0026\u0026vis[man[i].fa]==0) { family[t].people++; vis[man[i].fa]=1; } if(man[i].ma!=-1\u0026\u0026vis[man[i].ma]==0) { family[t].people++; vis[man[i].ma]=1; } for(int j=1;j\u003c=man[i].k;j++) { if(man[i].kid[j]!=-1\u0026\u0026vis[man[i].kid[j]]==0) {\tfamily[t].people++; vis[man[i].kid[j]]=1; } } family[t].nhouse+=man[i].nhouse; family[t].phouse+=man[i].phouse; } } for(int i=1;i\u003c=id;i++) {\tif(family[i].people\u003e0) { family[i].nhouse/=family[i].people; family[i].phouse/=family[i].people; } } if(id\u003e1) sort(family+1,family+id+1,cmp);//按题目意思排序 \tcout\u003c\u003cid\u003c\u003cendl; for(int i=1;i\u003c=id;i++) printf(\"%04d %d %.3f %.3f\\n\",family[i].m,family[i].people,family[i].nhouse,family[i].phouse); }   整除光棍 原题链接\n题目大意： 给你一个不以5结尾的奇数x ，求形如1，11，111，1111这样形式的数能整除x的最小解。\n输出 第一个数字s，表示x乘以s是一个光棍，第二个数字n是这个光棍的位数。\n输入样例： 31\r输出样例： 3584229390681 15\r思路： 肯定是一道大数题。我们要1，11，111依次枚举过去找出最优解。\n高精度除法。\nAC代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  #include\u003cbits/stdc++.h\u003eusing namespace std; int ans[1000]; int main() {\tint x; cin\u003e\u003ex; int sum=1,cnt=1;//cnt表示光棍位数 \twhile(sum!=0) { if(sum\u003cx) ans[cnt]=0;//除不下添0 \telse { ans[cnt]=sum/x;//记录商 \tsum=sum%x; } if(sum==0) break; sum=sum*10+1; cnt++; } int flag=0; for(int i=1;i\u003c=cnt;i++) { if(ans[i]) flag=1;//去掉前缀0 \tif(flag) cout\u003c\u003cans[i]; } cout\u003c\u003c\" \"\u003c\u003ccnt; }   部落 原题链接\n题目大意： 给出若干个部落，认为朋友的朋友都算在一个部落里。求这个社区的总人数以及互不相交的部落个数。\n再给出若干个查询，询问两人是否在同一部落。\n输入样例： 4\r3 10 1 2\r2 3 4\r4 1 5 7 8\r3 9 6 4\r2\r10 5\r3 7\r输出样例： 10 2\rY\rN\r思路： 又是一道并查集。\n可以用set去重的特性直接来统计社区的总人数，然后遍历set去统计部落个数即可。\nAC代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76  #include\u003cbits/stdc++.h\u003eusing namespace std; #define MAX_N 50010 int par[MAX_N]; int high[MAX_N];//树的高度 void init(int n) { for(int i=0;i\u003cn;i++) { par[i]=i; high[i]=0; } } int find(int x) { if(par[x]==x) return x; else return par[x]=find(par[x]); } void unite(int x,int y) { x=find(x); y=find(y); if(x==y) return; if(high[x]\u003chigh[y]) par[x]=y; else { par[y]=x; if(high[x]==high[y]) high[x]++; } } bool same(int x,int y) { return find(x)==find(y);\t} set\u003cint\u003es; int main() { int n; cin\u003e\u003en; init(10000+10); while(n--) { int k; cin\u003e\u003ek; int x; cin\u003e\u003ex; s.insert(x); k--; for(int i=1;i\u003c=k;i++) {\tint y; cin\u003e\u003ey; s.insert(y); unite(x,y); } } set\u003cint\u003e::iterator it; int sum=0,len=s.size(); for(it=s.begin ();it!=s.end ();it++) { if(par[*it]==*it) sum++; } cout\u003c\u003clen\u003c\u003c\" \"\u003c\u003csum\u003c\u003cendl; int q; cin\u003e\u003eq; while(q--) { int a,b; cin\u003e\u003ea\u003e\u003eb; if(same(a,b)) puts(\"Y\"); else puts(\"N\"); } }   深入虎穴 原题链接\n题目大意： 一扇门可以通往若干扇门，找到距离入口最远的那扇门。（不存在两条路通向同一扇门）\n有个易坑点：入口没有确定。不是每次入口为1。因为不会有门通向入口，所以输入数据中没有出现过的那扇门就是入口了。\n然后bfs或者dfs均可。\nAC代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  #include\u003cbits/stdc++.h\u003eusing namespace std; int vis[100000+10],maxx=0; vector\u003cint\u003eg[100000+10]; struct node { int step; int pos; }cur,nex; void bfs(int s) {\tcur.pos=s; cur.step=0; queue\u003cnode\u003eque; que.push(cur); while(!que.empty()) { cur=que.front(); que.pop(); for(int i=0;i\u003cg[cur.pos].size();i++) { nex.pos=g[cur.pos][i]; nex.step=cur.step+1; que.push(nex); } } cout\u003c\u003ccur.pos\u003c\u003cendl; } int main() { int n; cin\u003e\u003en; for(int i=1;i\u003c=n;i++) { int k; cin\u003e\u003ek; while(k--) { int num; cin\u003e\u003enum; vis[num]=1; g[i].push_back(num); } } int st; for(int i=1;i\u003c=n;i++) { if(!vis[i]) { st=i; break; } }//找入口 \tbfs(st); }   彩虹瓶 原题链接\n思路： 题目模拟的过程其实就是一种数据结构：stack。\nstack和queue类似，区别就是先进后出，后进先出。\n那么按题意模拟即可。\nAC代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  #include\u003cbits/stdc++.h\u003eusing namespace std; int a[1500],vis[1500]; int main() { int n,m,k; cin\u003e\u003en\u003e\u003em\u003e\u003ek; while(k--) {\tint flag=1; memset(vis,0,sizeof(vis)); for(int i=1;i\u003c=n;i++) { cin\u003e\u003ea[i]; } int num=1,now=1; stack\u003cint\u003es; while(num!=n) {\tif(a[now]==num)//刚好可以直接放的情况 \t{ num++; now++; continue; } else if(!s.empty()\u0026\u0026s.top()==num)//货架顶部刚好是的情况 \t{ s.pop(); num++; } else if(s.size()\u003cm)//暂时先不能放的情况，如果货架还有空间的话push \t{\tvis[a[now]]=1; s.push(a[now++]); }\telse { flag=0; break; } } if(flag) puts(\"YES\"); else puts(\"NO\"); } }   ","description":"","tags":null,"title":"天梯训练赛1 3 4","uri":"/posts/%E5%A4%A9%E6%A2%AF%E8%AE%AD%E7%BB%83%E8%B5%9B1-3-4/"},{"categories":["数据结构与算法"],"content":"红色警报 原题链接\n题意： 给你一副可能有若干连通分量的无向图，让你判断失去一座城市后，连通分量数是否发生变化。\n注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性，则不要发出警报。\n也就是说，只要考虑连通分量数变多的情况，孤立的一座城市失去导致连通分量数减少不用发出警告。\n思路： 利用并查集构图并求得连通分量数。（利用每块集合根节点par[x]==x的性质求得连通分量数）。\n每次攻占一座城市后，标记一下，初始化并查集，再去掉被标记的城市的道路，重新构图求连通分量数。如果连通分量数增加了，就发出警报。\n输出格式： 对每个被攻占的城市，如果它会改变整个国家的连通性，则输出Red Alert: City k is lost!，其中k是该城市的编号；否则只输出City k is lost.即可。如果该国失去了最后一个城市，则增加一行输出Game Over.。\n输入样例： 5 4\r0 1\r1 3\r3 0\r0 4\r5\r1 2 0 4 3\r输出样例： City 1 is lost.\rCity 2 is lost.\rRed Alert: City 0 is lost!\rCity 4 is lost.\rCity 3 is lost.\rGame Over.\rAC代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  #include\u003cbits/stdc++.h\u003eusing namespace std; const int maxn=1000; int par[maxn],vis[maxn],d[maxn][maxn]; void init(int n) { for(int i=0;i\u003cn;i++) par[i]=i; } int find(int x) { if(par[x]==x) return x; else return par[x]=find(par[x]); } void unite(int x,int y) { x=find(x); y=find(y); if(x==y) return; else par[x]=y; } int main() { int n,m,sum=0; cin\u003e\u003en\u003e\u003em; init(n); while(m--) { int x,y; cin\u003e\u003ex\u003e\u003ey; d[x][y]=1; unite(x,y); } for(int i=0;i\u003cn;i++) { if(par[i]==i) sum++; } //cout\u003c\u003csum\u003c\u003cendl; \tint q,ssum=0,tot=0; cin\u003e\u003eq; while(q--) {\tssum=0; tot++; int lose; cin\u003e\u003elose; init(n); for(int i=0;i\u003cn;i++) vis[lose]=1; for(int i=0;i\u003cn;i++) for(int j=0;j\u003cn;j++) if(d[i][j]\u0026\u0026!vis[i]\u0026\u0026!vis[j]) unite(i,j); for(int i=0;i\u003cn;i++) { if(par[i]==i\u0026\u0026!vis[i]) ssum++; } if(ssum\u003esum) { cout\u003c\u003c\"Red Alert: \"; printf(\"City %d is lost!\\n\",lose); } else printf(\"City %d is lost.\\n\",lose); sum=ssum; } if(tot==n) cout\u003c\u003c\"Game Over.\"\u003c\u003cendl; }   列车调度 原题链接\n题意： 给你一串不重复的数。求其中递减子序列的最少个数。\n输入样例： 9\r8 4 2 5 3 9 1 6 7\r输出样例： 4\r思路： 贪心。\n我们假设刚开始有个8，然后来了个4，2，都可以进8的隧道。此时1号隧道最小元素为2。\n然后又来了个5，进不了，就新加一个隧道，接着3也进来了，此时2号隧道最小元素为3.\n紧接着来了个9。3号隧道 来了个1，3个隧道都可以进，我们当然选择1号隧道，因为1号隧道的最小元素为2，在所有隧道中大于1的元素里是最近的（贪心）。往后以此类推就好了。\n也就是说，我们只需要用一个数组来保存每个隧道的最小元素，每个进来的数查找大于并最接近的那个隧道进去，找不到就新建一个隧道。\n这里的查找可以直接用upper——bound，因为a数组一定是从小到大排好序的。比如a[1]=2，那么接下来的a中就不会有比2更小的，如果有，那a[1]就该是那个比2小的数而不是2了。\nAC代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #include\u003cbits/stdc++.h\u003eusing namespace std; int a[100000+10]; int main() { int n,num=0; cin\u003e\u003en; int x; cin\u003e\u003ex; a[num++]=x; n--; while(n--) { cin\u003e\u003ex; int find=upper_bound(a,a+num,x)-a; if(find\u003e=0\u0026\u0026find\u003cnum) a[find]=x; else a[num++]=x; } cout\u003c\u003cnum\u003c\u003cendl; }   愿天下有情人都是失散多年的兄妹 原题链接\n题意： 先给出若干 个人的ID，性别，父亲ID，母亲ID。\n然后给出若干个询问（保证是同辈）是否能结婚。（ 两个人最近的共同祖先如果在五代以内（即本人、父母、祖父母、曾祖父母、高祖父母）则不可通婚 ）。\n输出格式： 对每一对有情人，判断他们的关系是否可以通婚：如果两人是同性，输出Never Mind；如果是异性并且关系出了五服，输出Yes；如果异性关系未出五服，输出No。\n输入样例： 24\r00001 M 01111 -1\r00002 F 02222 03333\r00003 M 02222 03333\r00004 F 04444 03333\r00005 M 04444 05555\r00006 F 04444 05555\r00007 F 06666 07777\r00008 M 06666 07777\r00009 M 00001 00002\r00010 M 00003 00006\r00011 F 00005 00007\r00012 F 00008 08888\r00013 F 00009 00011\r00014 M 00010 09999\r00015 M 00010 09999\r00016 M 10000 00012\r00017 F -1 00012\r00018 F 11000 00013\r00019 F 11100 00018\r00020 F 00015 11110\r00021 M 11100 00020\r00022 M 00016 -1\r00023 M 10012 00017\r00024 M 00022 10013\r9\r00021 00024\r00019 00024\r00011 00012\r00022 00018\r00001 00004\r00013 00016\r00017 00015\r00019 00021\r00010 00011\r输出样例： Never Mind\rYes\rNever Mind\rNo\rYes\rNo\rYes\rNo\rNo\r思路： 本来想着这种亲属关系用并查集。但是要判断五代以及一个人的父节点会有2个。处理起来就特别麻烦。\n赛后发现其实只要先把每个人的父母亲记录下来。然后对于每对询问，把一个人的五代存入set中，看看另外一个人的五代有没有人在set中就好了。\n访问一个人的五代可以用dfs。\n注意：\n1.父母的性别也要存。因为询问中可能会问a的母亲和b的母亲能不能通婚。\n2.添加和访问前先判断一下其父母是不是可究（-1）\nAC代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  #include\u003cbits/stdc++.h\u003eusing namespace std; const int maxn=1e5+10; int fa[maxn],ma[maxn],flag; char sex[maxn]; set\u003cint\u003es; void add(int x,int num) { if(num\u003e=5) return ; s.insert(x); if(fa[x]!=-1)add(fa[x],num+1); if(ma[x]!=-1)add(ma[x],num+1); } void dfs(int x) {\tif(s.find(x)!=s.end()) { flag=0; return; } if(ma[x]!=-1)dfs(ma[x]); if(fa[x]!=-1)dfs(fa[x]); } int main() { int n; cin\u003e\u003en; memset(fa,-1,sizeof(fa)); memset(ma,-1,sizeof(ma)); for(int i=1;i\u003c=n;i++) {\tint id,fath,math; char sx; cin\u003e\u003eid\u003e\u003esx\u003e\u003efath\u003e\u003emath; fa[id]=fath; ma[id]=math; sex[id]=sx; sex[fath]='M'; sex[math]='F'; } int q; cin\u003e\u003eq; while(q--) {\tflag=1; int x,y; cin\u003e\u003ex\u003e\u003ey; s.clear(); if(sex[x]==sex[y]) cout\u003c\u003c\"Never Mind\"\u003c\u003cendl; else {\tadd(x,0); dfs(y); if(flag) cout\u003c\u003c\"Yes\"\u003c\u003cendl; else cout\u003c\u003c\"No\"\u003c\u003cendl; } } }   今日总结： 前面的水题切的还不够快。代码实现能力还是有待加强。\n后面的题目赛后能补，赛时也要胆大心细的去尝试。\n加油吧！\n晚上还有场cf，又要掉分了（逃\n","description":"","tags":null,"title":"天梯训练赛2","uri":"/posts/%E5%A4%A9%E6%A2%AF%E8%AE%AD%E7%BB%83%E8%B5%9B2/"},{"categories":["数据结构与算法"],"content":"字典树 所谓字典树，其实就是n叉树。主要用于处理大量字符串，查找单词的操作。其原理是合并单词的公共前缀，再利用公共前缀大幅提供查找单词的效率。\n举个栗子，比如有abc,abd,bc,c四个单词，构建树就如下图。\n如上图，每个字典树都有一个0节点，接下来的节点建立按插入单词的顺序依次编号，相同前缀共用。\n因此我们设**tree[root] [id]**存储一个节点的编号，root代表该节点父节点的编号，id则是该节点对应的字母。\n（a-0，b-1，c-2……）\n对于每个确实存在的单词，我们用**flag[tot]**数组来表示是否存在。例如上图中的flag[3]=true,代表存在abc这个单词。\n下面贴上模板代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  #include\u003cbits/stdc++.h\u003e#define ll long long using namespace std; const int maxn=2e6+5; int tree[maxn][30],tot=0; bool flag[maxn]; void add(string s) { int root=0,id,len=s.size(); for(int i=0;i\u003clen;i++) { id=s[i]-'a'; if(!tree[root][id]) tree[root][id]=++tot; root=tree[root][id]; } flag[root]=true; } bool find(string s) { int root=0,id,len=s.size(); for(int i=0;i\u003clen;i++) { id=s[i]-'a'; if(!tree[root][id]) return false; root=tree[root][id]; } if(flag[root]) return true; else return false; }   ","description":"","tags":["字典树"],"title":"字典树","uri":"/posts/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"categories":["数据结构与算法"],"content":"矩阵快速幂 快速幂可以将o（n）的复杂度降为o（logn）\n原理如下：\n任何一个整数均可以用二进制来表示。\n当我们要求x^n时，\n可以先将n表示为2^k1+2^k2+2^k3.......\n那么x^n=x^(2^k1) * x^(2^k2) * x^(2^k3)......\n举个例子：22=10110\n那么x^22=x^16 * x^4 * x^2;\n下面是代码\n1 2 3 4 5 6 7 8 9 10 11  mat quickpow(ll x,ll n,ll mod) { ll res=1; while(n) { if(n\u00261) res=res*x%mod;//如果二进制最低位为1，则乘上x^(2^i) \tx=x*x%mod; n\u003e\u003e=1; } return res; }   同理，我们也可以做到矩阵快速幂，只需将算术乘法换成矩阵乘法即可。\n矩阵快速幂常常用于加速递推公式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #include\u003cbits/stdc++.h\u003e#define ll long long #define MAX_N 100 using namespace std; struct mat { ll a[MAX_N][MAX_N]; }; mat mul(mat A,mat B,int mod) {\tmat C; for(int i=0;i\u003cN;i++) for(int j=0;j\u003cN;j++) { C.a[i][j]=0; for(int k=0;k\u003cN;k++) C.a[i][j]+=(A.a[i][k]*B.a[k][j])%mod; } return C; } mat mpow(mat A,int n) { mat c; memset(c.a,0,sizeof(c.a)); for(int i=0;i\u003cN;i++) c.a[i][i]=1; while(n) { if(n\u00261) c=mul(c,A); A=mul(A,A); n\u003e\u003e=1; } return c; }   ","description":"","tags":["快速幂","数论"],"title":"矩阵快速幂","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"categories":["数据结构与算法"],"content":"Dijkstra算法 适用于解决没有负边的单源最短路问题，相比于Bellman-Ford虽然有处理负边的局限，但是可以通过优先队列实现O(E logV)的复杂度。\n本质其实是一种贪心思想。\n我们只需要找到最短距离已经确定的顶点，从它出发更新相邻顶点的最短距离。\n那么如何找到最短距离已经确定的顶点呢？\n首先，初始点d[s]=0为已知最短距离已经确定的顶点。\n然后，以它出发更新，那么在与起点S相邻且距离最短的点A就是可以确定的第2个最短距离点。\n为什么可以确定呢？因为假设S-\u003eA的距离不是最短的，那么一定存在一个中转点B位于S-\u003eA之间。\n但是S直接到A的距离是S到与其相邻点中最短的，光S-\u003eB的距离就已经大于S-\u003eA了。所以假设不成立。\n那么接下来要做的就是以此类推了，\n从A开始更新相邻顶点的最短距离，再从这些顶点中挑出与点A相距最短的那个顶点继续更新，知道所有顶点都被更新过为止。\n那么按照图用邻接矩阵存或邻接表存该算法有两种实现方法：\n按邻接矩阵存图：\n初始化\n建图时 r[i] [j] 初始化为INF，r[i] [i]初始化为0\n求最短路前 d[v]先全设为INF，d[源点]=0；\n还原路径时 pre[v]可以全设为-1，方便路径还原\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  struct edge { int to,cost; }; int d[MAX_V],vis[MAX_V]，r[MAX_V][MAX_V]; int pre[MAX_V]; void dijkstra(int s) {\tmemset(pre,-1,sizeof(pre)); memset(d,0x3f,sizeof(d)); memset(vis,0,sizeof(vis)); d[s]=0; for(int i=0;i\u003cn;i++) {\tint MIN=inf; int p; for(int j=0;j\u003cn;j++) {\tif(!vis[j]\u0026\u0026d[j]\u003cMIN) { p=j; MIN=d[j]; } }//从尚未使用过的顶点中选择一个距离最小的点 \tvis[p]=1; if(MIN==inf) break;\t//所有顶点都已经用过 \tfor(int j=0;j\u003cn;j++) { d[j]=min(d[j],d[p]+r[p][j]);//更新相邻顶点的最短距离  pre[j]=p; }\t} }   按邻接表存图：\n初始化\n建图的时候 记得G[MAX_V].clear( );\n计算最短路前 d[v]先全设为INF，d[源点]=0；\n还原路径时 pre[v]可以全设为-1，方便路径还原\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  #include\u003cbits/stdc++.h\u003e#define PII pair\u003cint,int\u003e //first最短距离，second顶点编号 #define MAX_V 100 using namespace std; const int inf=0x3f3f3f3f; struct edge { int to,cost; }; vector\u003cedge\u003eG[MAX_V]; int d[MAX_V]; int pre[MAX_V]; void dijkstra(int s) {\tpriority_queue\u003cPII,vector\u003cPII\u003e,greater\u003cPII\u003e \u003eque; memset(pre,-1,sizeof(pre)); memset(d,0x3f,sizeof(d)); d[s]=0; que.push(PII(0,s)); while(!que.empty()) { PII p=que.top(); que.pop(); int v=p.second; if(d[v]\u003cp.first) continue;//已经不是最短距离了就舍弃 \tfor(int i=0;i\u003cG[v].size();i++) { edge e=G[v][i]; if(d[e.to]\u003ed[v]+e.cost) { d[e.to]=d[v]+e.cost; que.push(PII(d[e.to],e.to));//更新相邻顶点距离入队  pre[e.to]=v; } } } } void getpath(int t) //还原路径 { int i; for( i=0;i\u003c=n;i++) {\tpath[i]=t; t=pre[t]; if(t==-1) break; } reverse(path,path+i); }   ","description":"","tags":["最短路","图论"],"title":"Dijkstra+路径还原","uri":"/posts/dijkstra/"},{"categories":["数据结构与算法"],"content":"Floyd-Warshall算法 适用于求解任意两点间的最短路问题。\n本质思想还是dp。\n在只使用了0-k个顶点和i,j的情况下，我们记i到j的最短路长度为d[k] [i] [j]。\n那么只使用0-k时，i到j的最短路情况可分为正好经过k点一次和完全不经过顶点k。\n不经过顶点k的情况下，d[k] [i] [j]=d[k-1] [i] [j]；\n经过顶点k的情况下，d[k] [i] [j]=d[k-1] [i] [k]+d[k-1] [k] [j].\n合起来，就得到了d[k] [i] [j]=min{d[k-1] [i] [j]，d[k-1] [i] [k]+d[k-1] [k] [j]}，那么其实只要使用同一个数组，不断进行**d[k] [i] [j]=min{d [i] [j]，d [i] [k]+d[k] [j]}**的更新就好了。\n初始化\n建图的时候 d[i] [j] 先全设为INF（表示两点之间没有路）,d[i] [i]设为0；\n还原路径 记录前趋：如同Bellman和dijkstra算法一样，Floyd也可以通过记录前趋来还原路径。\n用pre[i] [j]来表示以i为起点，j的前趋。先初始化pre[i] [j]=i,同时pre[i] [i]=-1,方便还原路径。之后每次更新最短路更新pre[i] [j]=pre[k] [j]即可。\n记录后趋：\n不过其实floyd可以完全使用记录后趋的方法，还能省去记录前趋后还原的步骤，因此推荐使用这种方法。\n用pre[i] [j]来表示以j为终点，i的后趋。先初始化pre[i] [j]=j,同时pre[j] [j]=-1,方便还原路径。之后每次更新最短路更新pre[i] [j]=pre[i] [k]即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  int d[MAX_V][MAX_V]; int V; int pre[MAX_V][MAX_V]; void floyd_warshall() {\tfor(int k=0;k\u003cV;k++) for(int i=0;i\u003cV;i++) for(int j=0;j\u003cV;j++) { d[i][j]=min(d[i][j],d[i][k]+d[k][j]); pre[i] [j]=pre[i] [k]；//记录后趋  } } void init() { for(int i=0;i\u003cV;i++) for(int j=0;j\u003cV;j++) { if(i==j) pre[i][j]=-1; else pre[i][j]=j; } } void getpath(int st,int ed) {\tint t; `\tprintf(\"%d\",st); while(t != -1) { printf(\"--\u003e%d\",t); t = p[t][ed]; } }   代码如此简洁，时间复杂度就大了，有O(V^3)呢！\n可适用于有负边的情况，如果要判断图中是否有负圈，只需检查是否存在d[i] [i]是负数的顶点即可。\n","description":"","tags":["最短路","图论"],"title":"Floyd-Warshall+路径还原","uri":"/posts/floyd-warshall/"},{"categories":["数据结构与算法"],"content":"Bellman-Ford 算法 适用于解决单源最短路问题，即固定一个起点，求它到其他所有点的最短路的问题。\n本质思想为dp。\n记从起点s出发到顶点i的最短距离为d[i]。\n则有d[i]=min{d[j]+从j直接到i边的距离}\n那么我们只要初始化d[s]=0，d[i]=INF，再不断使用这条递推关系式更新d[i]。只要图中没有负圈，这样的更新操作一定是有限的。结束之后的d[i]就是最短距离了。\n初始化\n建图的时候 e.cost 先全设为INF（表示两点之间没有路）\ndp前 d[v]先全设为INF，d[源点]=0；\n还原路径时 pre[v]可以全设为-1，方便路径还原\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  struct edge { int from,to,cost; }; edge es[MAX_E]; int d[MAX_V],pre[MAX_V],path[MAX_V]; int V,E;//v顶点数 E边数 int Bellman-Ford（int s） {\tmemset(pre,-1,sizeof(pre)); memset(d,0x3f,sizeof(d)); d[s]=0; for(int i=0;i\u003cV;i++) {\tint flag=0; for(int j=0;j\u003cE;j++) { edge e=es[j]; if(d[e.to]\u003ed[e.from]+e.cost) { d[e.to]=d[e.from]+e.cost; pre[e.to]=e.from; flag=1; } if(i==v-1\u0026\u0026flag==1) return -1;//如果第v次更新了，则存在负圈  if(flag==0) return 1;//flag=0 此次没更新，表示更新已经结束，直接退出  } } } void getpath(int t) //还原路径 { int i; for( i=0;i\u003c=n;i++) {\tpath[i]=t; t=pre[t]; if(t==-1) break; } reverse(path,path+i); }   这里解释一下为什么外循环至多只要执行v-1次。\n如果在图中没有负圈，那么任何一条最短路径都不会经过同一个顶点两次（也就是说，最多通过v-1条边）\n对于外循环而言，最差的情况（即线路是从D-\u003eC-\u003eB-\u003eA倒着给的）每次也能更新一条边，所以最多只要循环v-1次。\n因此Bellman-Ford算法的复杂度为O（V*E），而且可以适用于存在负边的情况。\n","description":"","tags":["最短路","图论"],"title":"Bellman-Ford+路径还原","uri":"/posts/bellman-ford/"},{"categories":["数据结构与算法"],"content":"From poj 2431\nDescription 一群母牛抓住卡车，冒险进入丛林深处。不幸的是，作为母牛的司机，这些母牛设法跑过一块岩石，刺穿了卡车的油箱。现在，卡车每行驶一段距离，就会泄漏一单位燃油。\n要修理卡车，奶牛需要沿着一条蜿蜒曲折的道路驶向最近的城镇（相距不超过1,000,000单位）。在这条道路上，在城镇和卡车的当前位置之间，有N个（1 \u003c= N \u003c= 10,000）加油站，奶牛可以停下来获取更多的燃料（每站1.100单位）。\n丛林对人类来说是一个危险的地方，对奶牛来说尤其危险。因此，奶牛希望在前往小镇的途中尽可能少地停下加油站。幸运的是，他们的卡车上的油箱容量很大，以至于它可以容纳的燃油量实际上没有限制。卡车目前离镇区L单位，有P单位燃料（1 \u003c= P \u003c= 1,000,000）。\n确定到达城镇或奶牛根本无法到达城镇所需的最少停靠站数。\nInput *第1行：一个整数，N\n*第2..N + 1行：每行包含两个以空格分隔的整数，用于描述加油站：第一个整数是从城镇到停靠站的距离；第二个是该站的可用燃料量。\n*第N + 2行：两个以空格分隔的整数L和P\nOutput *第1行：一个整数，给出到达市区所需的最少燃料停止数量。如果无法到达该镇，则输出-1。\nSample Input 4\r4 4\r5 2\r11 5\r15 10\r25 10\rSample Output 首先这道题题目的输入是终点到加油站的距离而不是起点到加油站的距离，而且数据并不是一定从小到大的输入。因此要先转化一下并sort。（被坑惨了）\n接下来这题只要转化一下思路就行了，因为燃料箱是无限的，所以可以把“路过一个加油站是否加油”等价于“路过一个加油站，在之后永久获得一次随时加油的机会”。\n那么只要保证每次油不够时选择已经路过加油站中最大的加油即可，因为每次都是选择最大，所以可以考虑优先队列来实现。\nAC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  #include\u003ccstdio\u003e#include\u003ciostream\u003e#include\u003calgorithm\u003e#include\u003cqueue\u003eusing namespace std; int n,l,p; struct stop { int dis; int fue; }s[10000+5]; bool cmp(stop s1,stop s2) { return s1.dis\u003cs2.dis; } void solve() { int tank=p,pos=0,ans=0; s[n].dis=l,s[n].fue=0; priority_queue\u003cint\u003eque; for(int i=0;i\u003c=n;i++) { int d=s[i].dis-pos; while(tank\u003cd) { if(que.empty()) { puts(\"-1\"); return; } tank=tank+que.top(); //cout\u003c\u003cque.top()\u003c\u003cendl; \tque.pop(); ans++; } tank-=d; pos=s[i].dis; que.push(s[i].fue); } cout\u003c\u003cans\u003c\u003cendl; } int main() { cin\u003e\u003en; for(int i=n-1;i\u003e=0;i--) { cin\u003e\u003es[i].dis\u003e\u003es[i].fue; } cin\u003e\u003el\u003e\u003ep; for(int i=0;i\u003cn;i++) { s[i].dis=l-s[i].dis; //cout\u003c\u003cs[i].dis\u003c\u003c\" \"\u003c\u003cs[i].fue\u003c\u003cendl; \t} sort(s,s+n,cmp); solve(); }   ","description":"","tags":["贪心","优先队列"],"title":"Expedition","uri":"/posts/expedition%E8%B4%AA%E5%BF%83-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["数据结构与算法"],"content":"From\npoj 3253\nDescription\n农夫约翰想修复牧场周围的一小部分篱笆。他测量围栏，并发现他需要Ñ（1≤ Ñ ≤20000）厚木板，每一个都具有一些整数长度大号我（1≤ 大号我 ≤50000）单元。然后，他购买了一块足够长的单块长板，足以切入N块木板（即，其长度为长度L i的总和）。FJ忽略了“锯缝”，即锯切时因锯末而损失的额外长度；您也应该忽略它。\nFJ遗憾地意识到自己没有切割木头的锯子，于是用长木板将其镶嵌到Farmer Don's Farm上，礼貌地询问他是否可以借用锯子。\n壁橱资本家农夫唐（Farmer Don）不借给FJ锯，而是提议就木板中的N -1个切口向农夫约翰收费。切割一块木头的费用恰好等于其长度。切割一块长度为21的木板的成本为21美分。\n然后，农夫唐让农夫约翰决定切割木板的顺序和位置。帮助农夫约翰确定他可以用来制作N块木板的最低金额。FJ知道他可以按各种不同的顺序切割木板，这将导致不同的费用，因为最终的中间木板长度不同。\nInput\n第1行：一个整数N，木板数 第2行至N +1行：每行包含一个整数，描述所需木板的长度\nOutput\n第1行：一个整数：要进行N -1次削减，他必须花费的最低金额\nSample Input\n3\n8\n5\n8\nSample Output\n34\n题目第一眼看上去很难入手，其实是一道奇特的贪心题。\n切割的方法可以看成二叉树，每一个叶子节点就对应了切割出的目标木板，叶子节点的深度就对应了得到这块目标所需的切割次数，开销的合计就是每个叶子节点的 木板长度×节点的深度\n由此可知，因为木板长度是固定的，所以为了使开销最小，应当使得小长度的木板尽可能节点深，也就是说最短的板与次短的板的节点应当是兄弟节点。这样只需建立优先队列，每次取出最短的2块板合成一块板，直到最后只剩一块板即可。\nAC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  #include\u003ccstdio\u003e#include\u003ciostream\u003e#include\u003calgorithm\u003e#include\u003cqueue\u003e#define ll long long using namespace std; int n; ll l[20000+10],ans,l1,l2; int main() { cin\u003e\u003en; priority_queue\u003cll,vector\u003cll\u003e,greater\u003cll\u003e \u003eque; for(int i=0;i\u003cn;i++) { cin\u003e\u003el[i]; que.push(l[i]); } while(n\u003e1) { l1=que.top(); que.pop(); l2=que.top(); que.pop(); que.push(l1+l2); ans+=l1+l2; n--; } cout\u003c\u003cans\u003c\u003cendl; }   ","description":"","tags":["贪心","优先队列"],"title":"Fence Repair","uri":"/posts/fence-repair%E8%B4%AA%E5%BF%83-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["数据结构与算法"],"content":"天使被MOLIGPY抓住了！他被莫利比（Moligpy）监禁。监狱被描述为N * M（N，M \u003c= 200）矩阵。监狱中有城墙，道路和护卫队。\n天使的朋友想救救天使。他们的任务是：接近天使。我们假设“接近天使”是要到达天使停留的位置。当网格中有守卫时，我们必须杀死他（或她？）才能进入网格。我们假设我们上下左右移动要花费我们1个单位时间，而杀死一名警卫也要花费1个单位时间。而且我们足够强大，可以杀死所有警卫。\n您必须计算与Angel接触的最短时间。（当然，我们只能将UP，DOWN，LEFT和RIGHT移动到边界内的相邻网格中。）\nInput\n第一行包含两个代表N和M的整数。然后N行，每行包含M个字符。“。” 代表道路，“ a”代表Angel，“ r”代表Angel的每个朋友。处理到文件末尾。\nOutput\n对于每个测试用例，您的程序应输出一个整数，代表所需的最短时间。如果不存在这样的数字，则应输出包含“可怜的ANGEL必须终生呆在监狱中”的行。\nSample Input\n7 8\r#.#####.\r#.a#..r.\r#..#x...\r..#..#.#\r#...##..\r.#......\r........\rSample Output\n13\r本来以为是一道普通的bfs题，题目为求a到任意一个r的最短距离，后来发现事情并没有这么简单。\n看下面这组数据：\n3 3 #xr #.. #a#\n如果依次加入队列的方向是上下左右的话，那么在最中间（1，1）加入队列后，先是上方（0，1）x加入队列，再是右边（1，2）加入队列，x先入队列会导致下次以x为起点宽搜时直接找到r并返回答案4。显然正确答案应该为3.\n那么有没有什么办法来保证每次都是先去搜没有经过x的路呢，也就是每次step少的数先出队列，答案是有的。就是这道题的主角——优先队列。\n相关定义 优先队列容器与队列一样，只能从队尾插入元素，从队首删除元素。但是它有一个特性，就是队列中最大的元素总是位于队首，所以出队时，并非按照先进先出的原则进行，而是将当前队列中最大的元素出队。这点类似于给队列里的元素进行了由大到小的顺序排序。元素的比较规则默认按元素值由大到小排序，可以重载“\u003c”操作符来重新定义比较规则。\n基本操作 empty() 如果队列为空，则返回真\npop()　删除对顶元素，删除第一个元素\npush() 加入一个元素\nsize() 返回优先队列中拥有的元素个数\ntop() 返回优先队列对顶元素，返回优先队列中有最高优先级的元素\n与普通队列类似，唯一有区别的地方就是front（）替换成了top（）\n结构体声明方式 struct node {\n　int x, y;\n　friend bool operator \u003c (node a, node b)\n　{\n　return a.x \u003e b.x; //结构体中，x小的优先级高\n　}\n};\npriority_queueq;\n（对于友员函数，重载什么的数据结构内容笔者还不够熟悉，所以不做过多说明，反正先用着，以后再来补坑）\n介绍完优先队列，那么这道题就迎刃而解了，只需要在原来的bfs基础上把队列换成优先队列，让步数少的先出列就行了。\nAC代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76  #include\u003cbits/stdc++.h\u003eusing namespace std; int n,m,vis[205][205]; char a[205][205]; int dx[]={-1,1,0,0},dy[]={0,0,1,-1}; struct pos { int x,y; int step; friend bool operator \u003c(pos t1,pos t2) { return t1.step\u003et2.step;//step小的在前 \t} }cur,nex; bool pd() { if(nex.x\u003c=n-1\u0026\u0026nex.x\u003e=0\u0026\u0026nex.y\u003e=0\u0026\u0026nex.y\u003c=m-1\u0026\u0026a[nex.x][nex.y]!='#'\u0026\u0026!vis[nex.x][nex.y]) return true; return false; } void bfs() { cur.step=0; priority_queue\u003cpos\u003eque; que.push(cur); while(!que.empty()) { cur=que.top(); que.pop(); if(a[cur.x][cur.y]=='r') { cout\u003c\u003ccur.step\u003c\u003cendl; return; } for(int i=0;i\u003c4;i++) { nex.x=cur.x+dx[i]; nex.y=cur.y+dy[i]; //printf(\"%d %d\\n\",nex.x,nex.y); \tif(pd()) {\tvis[nex.x][nex.y]=1; //printf(\"%d %d\\n\",nex.x,nex.y); \tif(a[nex.x][nex.y]=='x') { nex.step=cur.step+2; } else nex.step=cur.step+1; que.push(nex); } } } cout\u003c\u003c\"Poor ANGEL has to stay in the prison all his life.\"\u003c\u003cendl; } int main() { while(~scanf(\"%d%d\",\u0026n,\u0026m)) {\t//printf(\"here\\n\"); \tfor(int i=0;i\u003cn;i++) for(int j=0;j\u003cm;j++) {\tvis[i][j]=0; //printf(\"here\\n\"); \tscanf(\" %c\",\u0026a[i][j]); if(a[i][j]=='a') { cur.x=i; cur.y=j; vis[i][j]=1; } } bfs(); } return 0; }   ","description":"","tags":["BFS","优先队列"],"title":"Rescue","uri":"/posts/rescue/"},{"categories":["数据结构与算法"],"content":"Description\nDue to recent rains, water has pooled in various places in Farmer John's field, which is represented by a rectangle of N x M (1 \u003c= N \u003c= 100; 1 \u003c= M \u003c= 100) squares. Each square contains either water ('W') or dry land ('.'). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors.\nGiven a diagram of Farmer John's field, determine how many ponds he has.\nInput\n* Line 1: Two space-separated integers: N and M\n* Lines 2..N+1: M characters per line representing one row of Farmer John's field. Each character is either 'W' or '.'. The characters do not have spaces between them.\nOutput\n* Line 1: The number of ponds in Farmer John's field.\nSample Input\n10 12\rW........WW.\r.WWW.....WWW\r....WW...WW.\r.........WW.\r.........W..\r..W......W..\r.W.W.....WW.\rW.W.W.....W.\r.W.W......W.\r..W.......W.\rSample Output\n3\rdfs入门题。\n先找到任意一个W，不停地把其邻接部分用'.'代替，在代替的过程中如果碰到W把其邻接部分也用'.'代替。这样一次dfs完就代表一处水洼，到最后遍历完整个方阵没有W时，dfs的次数就是水洼数。\nAC代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  #include\u003cbits/stdc++.h\u003eusing namespace std; const int MAXN=200; int n,m; char f[MAXN][MAXN]; void dfs(int x,int y) { f[x][y]='.'; for(int i=-1;i\u003c=1;++i) { for(int j=-1;j\u003c=1;++j)//i，j控制遍历方向 \t{\tint nx=x+i,ny=y+j; if(nx\u003e=0\u0026\u0026nx\u003cn\u0026\u0026ny\u003e=0\u0026\u0026ny\u003cm\u0026\u0026f[nx][ny]=='W') dfs(nx,ny); } } } int main() { int ans=0; cin\u003e\u003en\u003e\u003em; for(int i=0;i\u003cn;i++) for(int j=0;j\u003cm;j++) cin\u003e\u003ef[i][j]; for(int i=0;i\u003cn;i++) { for(int j=0;j\u003cm;j++) { if(f[i][j]=='W') { dfs(i,j); ans++; } } } cout\u003c\u003cans\u003c\u003cendl; return 0;\t}   ","description":"","tags":["DFS"],"title":"Lake Counting","uri":"/posts/lake-counting/"},{"categories":["数据结构与算法"],"content":"题目描述 众所周知，duxing哥喜欢吃kfc。\n今天终于到了周二，duxing哥又可以去吃kfc了，于是他打开手机app自助点餐，发现附近有许多家kfc店，但是他想选择一家店并尽快取餐回到寝室，忽略到店取餐时间。\n地图可以被看做是一个n * m的网格，其中有一些不可通过的障碍，duxing哥、kfc和寝室所在的地方也可以看做是道路，可以通过。duxing哥可以在任意一条道路中选择上下左右四个方向移动，一次移动算作一步。现从duxing初始位置出发，求取到kfc并且回到家的最少步数。\n输入 输入包含多个测试用例。\n每个测试用例都包括前两个整数n，m。(1\u003c=n,m\u003c=1000)\n接下来的n行，每行包含m个字符，表示地图。\n​ ‘S’表示duxing哥的初始位置；\n​ ‘E’表示寝室的位置；\n​ ‘＃’表示障碍；\n​ ‘.’表示道路；\n​ ‘K’表示kfc。\n输出 对于每个测试用例输出一行一个整数，duxing哥带上kfc并且回到寝室需要的最少步数。如果无解，请输出“-1”。\n样例输入 5 5\rS..##\r##..K\rK..#.\r#.#.K\r#.K#E\r5 5\rS..##\r##..K\rK..#.\r#.#.#\r#.K#E\r5 5\rS....\r.....\r.....\r.....\r....E\r样例输出 8\r-1\r-1\rc++版本1：\n由于题目要求必须经过至少一家kfc，因此最短路径就是其中某一个k到起点的最短路径和到终点的最短路径。\n可以先bfs起点和终点2次来求得起点和终点到各个k的最短距离，最后加起来求得每个k的总路径，最小的即为答案。\n（第一次写bfs，可能代码有些繁琐了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82  #include\u003cbits/stdc++.h\u003eusing namespace std; const int MAX=1000+10; char f[MAX][MAX]; struct pos { int x; int y; }; int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1}; int dis[MAX][MAX],n,m,vis[MAX][MAX],k1[MAX][MAX],k2[MAX][MAX];//每个k到起（终）点的距离存储在k1（2）中 int bfs(pos start,int k[][MAX],int sumk) {\tmemset(dis,0,sizeof(dis)); memset(vis,0,sizeof(vis)); pos cur,nex; queue\u003cpos\u003e que; que.push(start); while(!que.empty()\u0026\u0026sumk) {\tcur=que.front();que.pop(); if(f[cur.x][cur.y]=='K') { k[cur.x][cur.y]=dis[cur.x][cur.y]; //cout\u003c\u003ck[cur.x][cur.y]\u003c\u003cendl; \tsumk--; } for(int i=0;i\u003c4;i++) { nex.x=cur.x+dx[i];nex.y=cur.y+dy[i]; if(f[nex.x][nex.y]!='#'\u0026\u0026nex.x\u003e=0\u0026\u0026nex.x\u003cn\u0026\u0026nex.y\u003e=0\u0026\u0026nex.y\u003cm\u0026\u0026!vis[nex.x][nex.y]) { que.push(nex); vis[nex.x][nex.y]=1; dis[nex.x][nex.y]=dis[cur.x][cur.y]+1; } } } return dis[cur.x][cur.y]; } int main() { while(cin\u003e\u003en\u003e\u003em) {\tint min=1000010,ans=0,flag=0,sumk=0; pos begin1,begin2; for(int i=0;i\u003cn;i++) for(int j=0;j\u003cm;j++) { scanf(\" %c\",\u0026f[i][j]); if(f[i][j]=='S') { begin1.x=i; begin1.y=j; } else if(f[i][j]=='E') { begin2.x=i; begin2.y=j; } else if(f[i][j]=='K') sumk++; } memset(k1,0,sizeof(k1)); memset(k2,0,sizeof(k2)); bfs(begin1,k1,sumk); bfs(begin2,k2,sumk); for(int i=0;i\u003cn;i++) { for(int j=0;j\u003cm;j++) { if(k1[i][j]\u0026\u0026k2[i][j]) { flag=1; ans=k1[i][j]+k2[i][j]; if(ans\u003c=min) min=ans; } } } if(flag)cout\u003c\u003cmin\u003c\u003cendl; else cout\u003c\u003c\"-1\"\u003c\u003cendl; } }   c++版本2（感谢shn大佬提供的思路）：\n可以在之前二维数组dis的基础上再添加一维来表示状态（有没有遇到kfc）\nbfs状态转移前后都判断一下是否是k即可，而且这样扩充状态能保证bfs在经过kfc的条件下依然还是最短路径\n附上大佬的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76  #include\u003ccstdio\u003e#include\u003ciostream\u003e#include\u003ccstring\u003e#include\u003calgorithm\u003e#include\u003cqueue\u003e#include\u003cmap\u003eusing namespace std; const int inf=0x3f3f3f3f; const int maxn=1050; struct node{ int x,y,flag; }s,e; int n,m,dis[maxn][maxn][2]; char a[maxn][maxn]; int dx[]={1,-1,0,0}; int dy[]={0,0,1,-1}; bool calc(int x,int y,int z) { if(x\u003c0||x\u003e=n||y\u003c0||y\u003e=m) return false; if(a[x][y]=='#') return false; if(dis[x][y][z]!=inf) return false; return true; }//判断下一个坐标是否越界，障碍或已经走过 void bfs() { memset(dis,0x3f,sizeof(dis));//记笔记，memset初始最大值的方法0x3f  queue\u003cnode\u003e q; q.push(s); dis[s.x][s.y][0]=0; while(!q.empty()) { node t=q.front();q.pop(); if(t.x==e.x\u0026\u0026t.y==e.y\u0026\u0026t.flag) { cout\u003c\u003cdis[t.x][t.y][1]\u003c\u003cendl; return ; } for(int i=0;i\u003c4;i++) { int tx=t.x+dx[i],ty=t.y+dy[i]; int pan=0; if(t.flag) pan=1;//上一个点已经过了kfc  if(a[tx][ty]=='K') pan=1;//要走的那个点为kfc  if(!calc(tx,ty,pan)) continue; if(a[tx][ty]=='K') { q.push({tx,ty,1}); dis[tx][ty][1]=dis[t.x][t.y][t.flag]+1; } else { q.push({tx,ty,t.flag}); dis[tx][ty][t.flag]=dis[t.x][t.y][t.flag]+1; } } } puts(\"-1\"); } int main() { while(~scanf(\"%d%d\",\u0026n,\u0026m)) { for(int i=0;i\u003cn;i++) cin\u003e\u003ea[i]; for(int i=0;i\u003cn;i++) { for(int j=0;j\u003cm;j++) { if(a[i][j]=='S') s={i,j}; else if(a[i][j]=='E') e={i,j}; } } bfs(); } return 0; }   ","description":"","tags":["BFS"],"title":"吃kfc","uri":"/posts/%E5%90%83kfc/"},{"categories":["数据结构与算法"],"content":"Problem Description\nGiven a positive integer N, you should output the most right digit of N^N.\nInput\nThe input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.\nEach test case contains a single positive integer N(1\u003c=N\u003c=1,000,000,000).\nOutput\nFor each test case, you should output the rightmost digit of N^N.\nSample Input\n2\r3\r4\rSample Output\n7\r6\r刚开始想着变乘边取模（%10）发现依然tle，然后想到新学的快速幂\n快速幂：计算a^b%p（时间复杂度o（log2b））\n利用正数肯定能唯一表示为若干指数不重复的2次幂的和。\n例如b=5=1×（2^2）+0×（2^1）+1×（2^0），a=3\n所以3^5=3^(1×（2^2))×3^(0×（2^1）)×3^（1×（2^0））;等式右边相邻两项是平方关系\n用（b\u00261)可以表示b二进制的最后一位，对应上式中的0，1，只要在1的时候，把乘积项累积到答案中，而b\u003e\u003e1运算可以舍去最低位，在递推的过程中两者结合，即可遍历b在二进制表示下的所有位数\nAC代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #include\u003cbits/stdc++.h\u003eusing namespace std; #define p 10; int main() {\tlong long a,b; int n; cin\u003e\u003en; while(n--) { cin\u003e\u003ea; {\tb=a; long long ans=1; for(;b;b=b\u003e\u003e1) {\tif(b\u00261) ans=ans*a%p; a=a*a%p; } cout\u003c\u003cans\u003c\u003cendl; } } return 0;\t}   ","description":"","tags":["快速幂","数论"],"title":"快速幂","uri":"/posts/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"categories":["数据结构与算法"],"content":"Problem Description\nThe least common multiple (LCM) of a set of positive integers is the smallest positive integer which is divisible by all the numbers in the set. For example, the LCM of 5, 7 and 15 is 105.\nInput\nInput will consist of multiple problem instances. The first line of the input will contain a single integer indicating the number of problem instances. Each instance will consist of a single line of the form m n1 n2 n3 ... nm where m is the number of integers in the set and n1 ... nm are the integers. All integers will be positive and lie within the range of a 32-bit integer.\nOutput\nFor each problem instance, output a single line containing the corresponding LCM. All results will lie in the range of a 32-bit integer.\nSample Input\n2\r3 5 7 15\r6 4 10296 936 1287 792 1\rSample Output\n105\r10296\r利用公式：x*y=lcm(x，y)*gcd(x，y)即可\n本题需要注意点就是x乘y时可能爆int，所以可以x/gcd（x，y）再乘y防止溢出\n求gcd（x，y）时，可以考虑递归辗转相除法使得代码简洁\n1 2 3 4 5 6  int gcd(int x,int y) { if(y\u003ex) swap(x,y); if(x%y==0) return y; else return gcd(y,x%y); }   AC代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #include\u003cbits/stdc++.h\u003eusing namespace std; int gcd(int x,int y) { if(y\u003ex) swap(x,y); if(x%y==0) return y; else return gcd(y,x%y); } long long lcm(int x,int y) { return x/gcd(x,y)*y; } int main() { int n; cin\u003e\u003en; while(n--) { int len,begin; cin\u003e\u003elen; cin\u003e\u003ebegin; int ans=begin,k; len--; while(len--) { cin\u003e\u003ek; ans=lcm(ans,k); } cout\u003c\u003cans\u003c\u003cendl; } }   ","description":"","tags":["模拟"],"title":"Least Common Multiple","uri":"/posts/least-common-multiple/"}]
